[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Differential Geometry",
    "section": "",
    "text": "Welcome\nThese are the Lecture Notes of Differential Geometry 661955 for T1 2023/24 at the University of Hull. We will study curves and surfaces in \\(\\mathbb{R}^3\\). I will follow these lecture notes during the course. If you have any question or find any typo, please email me at\nUp to date information about the course, Tutorials and Homework will be published on the University of Hull Canvas Website\nand on the Course Webpage hosted on my website\nFeatures of these digital notes:"
  },
  {
    "objectID": "index.html#readings",
    "href": "index.html#readings",
    "title": "Differential Geometry",
    "section": "Readings",
    "text": "Readings\nThe main textbook of the course is Pressley [1]. Other interesting readings are the books by do Carmo [2] and Bär [3]. I will assume some knowledge from Analysis and Linear Algebra. A good place to revise these topics are the books by Zorich [4,5]."
  },
  {
    "objectID": "index.html#visualization",
    "href": "index.html#visualization",
    "title": "Differential Geometry",
    "section": "Visualization",
    "text": "Visualization\nIt is important to visualize the geometrical objects and concepts we are going to talk about in this course. I will show basic Python code to plot curves and surfaces. This part of the course is not required for the final examination. If you want to have fun plotting with Pyhton, I recommend installation through Anaconda or Miniconda. The actual coding can then be done through Jupyter Notebook. Good references for scientific Python programming are [6,7].\nIf you do not want to mess around with Python, you can still visualize pretty much everything we will do in this course using the excellent online 3D grapher tool CalcPlot3D. To understand how it works, please refer to the help manual or to the short video introduction.\n\n\n\n\n\n\nImportant\n\n\n\nYou are not expected to purchase any of the above books. These lecture notes will cover 100% of the topics you are expected to known in order to excel in the final exam.\n\n\n\n\n\n\n[1] A. Pressley, Elementary differential geometry, Second Edition, Springer, 2010.\n\n\n[2] M.P. do Carmo, Differential geometry of curves and surfaces, Second Edition, Dover Books on Mathematics, 2017.\n\n\n[3] C. Bär, Elementary differential geometry, Cambridge University Press, 2010.\n\n\n[4] V.A. Zorich, Mathematical analysis i, Second Edition, Springer, 2015.\n\n\n[5] V.A. Zorich, Mathematical analysis II, Second Edition, Springer, 2016.\n\n\n[6] R. Johansson, Numerical python. Scientific computing and data science applications with numpy, SciPy and matplotlib, Second Edition, Apress, 2019.\n\n\n[7] Q. Kong, T. Siauw, A. Bayen, Python programming and numerical methods, Academic Press, 2020."
  },
  {
    "objectID": "sections/chap_1_0.html",
    "href": "sections/chap_1_0.html",
    "title": "1  Introduction",
    "section": "",
    "text": "Coming soon"
  },
  {
    "objectID": "sections/chap_1_1.html#sec-plot-2d-curves",
    "href": "sections/chap_1_1.html#sec-plot-2d-curves",
    "title": "2  Plotting curves",
    "section": "2.1 Curves in 2D",
    "text": "2.1 Curves in 2D\nSuppose we want to plot the parabola \\(y=t^2\\) for \\(t\\) in the interval \\([-3,3]\\). In our language, this is the two-dimensional curve \\[\n\\gamma(t) = ( t, t^2 ) \\,, \\quad  t \\in [-3,3] \\,.\n\\] The two Python libraries we use to plot \\(\\gamma\\) are numpy and matplotlib. In short, numpy handles multi-dimensional arrays and matrices, and can perform high-level mathematical functions on them. For any question you may have about numpy, answers can be found in the searchable documentation available here. Instead matplotlib is a plotting library, with documentation here. Python libraries need to be imported every time you want to use them. In our case we will import:\nimport numpy as np\nimport matplotlib.pyplot as plt\nThe above imports numpy and the module pyplot from matplotlib, and renames them to np and plt, respectively. These shorthands are standard in the literature, and they make code much more readable.\nThe function for plotting 2D graphs is called plot(x,y) and is contained in plt. As the syntax suggests, plot takes as arguments two arrays \\[\nx=[x_1, \\ldots, x_n]\\,, \\quad  y=[y_1,\\ldots,y_n]\\,.\n\\] As output it produces a graph which is the linear interpolation of the points \\((x_i,y_i)\\) in \\(\\mathbb{R}^2\\), that is, consecutive points \\((x_i,y_i)\\) and \\((x_{i+1},y_{i+1})\\) are connected by a segment. Using plot, we can graph the curve \\(\\gamma(t)=(t,t^2)\\) like so:\n\n# Code for plotting gamma\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generating array t\nt = np.array([-3,-2,-1,0,1,2,3])\n\n# Computing array f\nf = t**2\n\n# Plotting the curve\nplt.plot(t,f)\n\n# Plotting dots\nplt.plot(t,f,\"ko\")\n\n# Showing the plot\nplt.show()\n\n\n\n\nLet us comment the above code. The variable t is a numpy array containing the ordered values \\[\nt = [-3,-2,-1,0,1,2,3]\\,.\n\\tag{2.1}\\] This array is then squared entry-by-entry via the operation \\(t\\ast\\!\\ast 2\\) and saved in the new numpy array f, that is, \\[\nf = [9,4,1,0,1,4,9] \\,.\n\\] The arrays t and f are then passed to plot(t,f), which produces the above linear interpolation, with t on the x-axis and f on the y-axis. The command plot(t,f,'ko') instead plots a black dot at each point \\((t_i,f_i)\\). The latter is clearly not needed to obtain a plot, and it was only included to highlight the fact that plot is actually producing a linear interpolation between points. Finally plt.show() displays the figure in the user window1.\nOf course one can refine the plot so that it resembles the continuous curve \\(\\gamma(t)=(t,t^2)\\) that we all have in mind. This is achieved by generating a numpy array t with a finer stepsize, invoking the function np.linspace(a,b,n). Such call will return a numpy array which contains n evenly spaced points, starts at a, and ends in b. For example np.linspace(-3,3,7) returns our original array t at 2.1, as shown below\n\n# Displaying output of np.linspace\n\nimport numpy as np\n\n# Generates array t by dividing interval \n# (-3,3) in 7 parts\nt = np.linspace(-3,3, 7)\n\n# Prints array t\nprint(\"t =\", t)\n\nt = [-3. -2. -1.  0.  1.  2.  3.]\n\n\nIn order to have a more refined plot of \\(\\gamma\\), we just need to increase \\(n\\).\n\n# Plotting gamma with finer step-size\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generates array t by dividing interval \n# (-3,3) in 100 parts\nt = np.linspace(-3,3, 100)\n\n# Computes f\nf = t**2\n\n# Plotting\nplt.plot(t,f)\nplt.show()\n\n\n\n\nWe now want to plot a parametric curve \\(\\gamma \\colon (a,b) \\to \\mathbb{R}^2\\) with \\[\n\\gamma(t) = (x(t), y(t)) \\,.\n\\] Clearly we need to modify the above code. The variable t will still be a numpy array produced by linspace. We then need to introduce the arrays x and y which ecode the first and second components of \\(\\gamma\\), respectively.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Divides time interval (a,b) in n parts\n# and saves output to numpy array t\nt = np.linspace(a, b, n)\n\n# Computes gamma from given functions x(y) and y(t)\nx = x(t)\ny = y(t)\n\n# Plots the curve\nplt.plot(x,y)\n\n# Shows the plot\nplt.show()\nWe use the above code to plot the 2D curve known as the Fermat’s spiral \\[\n\\gamma(t) = ( \\sqrt{t}  \\cos(t) , \\sqrt{t}  \\sin(t) ) \\quad\n\\text{ for } \\quad t \\in [0,50] \\,.\n\\tag{2.2}\\]\n# Plotting Fermat's spiral\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Divides time interval (0,50) in 500 parts\nt = np.linspace(0, 50, 500)\n\n# Computes Fermat's Spiral\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\n# Plots the Spiral\nplt.plot(x,y)\nplt.show()\nBefore displaying the output of the above code, a few comments are in order. The array t has size 500, due to the behavior of linspace. You can also fact check this information by printing np.size(t), which is the numpy function that returns the size of an array. We then use the numpy function np.sqrt to compute the square root of the array t. The outcome is still an array with the same size of t, that is, \\[\nt=[t_1,\\ldots,t_n]   \\quad \\implies \\quad \\sqrt{t} = [\\sqrt{t_1}, \\ldots, \\sqrt{t_n}] \\,.\n\\] Similary, the call np.cos(t) returns the array \\[\n\\cos(t) = [\\cos(t_1), \\ldots, \\cos(t_n)] \\,.\n\\] The two arrays np.sqrt(t) and np.cos(t) are then multiplied, term-by-term, and saved in the array x. The array y is computed similarly. The command plt.plot(x,y) then yields the graph of the Fermat’s spiral:\n\n\n\n\n\nFermat’s spiral\n\n\n\n\nThe above plots can be styled a bit. For example we can give a title to the plot, label the axes, plot the spiral by means of green dots, and add a plot legend, as coded below:\n\n# Adding some style\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Computing Spiral\nt = np.linspace(0, 50, 500)\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\n# Generating figure\nplt.figure(1, figsize = (4,4))\n\n# Plotting the Spiral with some options\nplt.plot(x, y, '--', color = 'deeppink', linewidth = 1.5, label = 'Spiral')\n\n# Adding grid\nplt.grid(True, color = 'lightgray')\n\n# Adding title\nplt.title(\"Fermat's spiral for t between 0 and 50\")\n\n# Adding axes labels\nplt.xlabel(\"x-axis\", fontsize = 15)\nplt.ylabel(\"y-axis\", fontsize = 15)\n\n# Showing plot legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\nAdding a bit of style\n\n\n\n\nLet us go over the novel part of the above code:\n\nplt.figure(): This command generates a figure object. If you are planning on plotting just one figure at a time, then this command is optional: a figure object is generated implicitly when calling plt.plot. Otherwise, if working with n figures, you need to generate a figure object with plt.figure(i) for each i between 1 and n. The number i uniquely identifies the i-th figure: whenever you call plt.figure(i), Python knows that the next commands will refer to the i-th figure. In our case we only have one figure, so we have used the identifier 1. The second argument figsize = (a,b) in plt.figure() specifies the size of figure 1 in inches. In this case we generated a figure 4 x 4 inches.\nplt.plot: This is plotting the arrays x and y, as usual. However we are adding a few aestethic touches: the curve is plotted in dashed style with --, in deep pink color and with a line width of 1.5. Finally this plot is labelled Spiral.\nplt.grid: This enables a grid in light gray color.\nplt.title: This gives a title to the figure, displayed on top.\nplt.xlabel and plt.ylabel: These assign labels to the axes, with font size 15 points.\nplt.legend(): This plots the legend, with all the labels assigned in the plt.plot call. In this case the only label is Spiral.\n\n\n\n\n\n\n\nMatplotlib styles\n\n\n\nThere are countless plot types and options you can specify in matplotlib, see for example the Matplotlib Gallery. Of course there is no need to remember every single command: a quick Google search can do wonders.\n\n\n\n\n\n\n\n\nGenerating arrays\n\n\n\nThere are several ways of generating evenly spaced arrays in Python. For example the function np.arange(a,b,s) returns an array with values within the half-open interval \\([a,b)\\), with spacing between values given by s. For example\n\nimport numpy as np\n\nt = np.arange(0,1, 0.2)\nprint(\"t =\",t)\n\nt = [0.  0.2 0.4 0.6 0.8]"
  },
  {
    "objectID": "sections/chap_1_1.html#implicit-curves-2d",
    "href": "sections/chap_1_1.html#implicit-curves-2d",
    "title": "2  Plotting curves",
    "section": "2.2 Implicit curves 2D",
    "text": "2.2 Implicit curves 2D\nA curve \\(\\gamma\\) in \\(\\mathbb{R}^2\\) can also be defined as the set of points \\((x,y) \\in \\mathbb{R}^2\\) satisfying \\[\nf(x,y)=0\n\\] for some given \\(f \\colon \\mathbb{R}^2 \\to \\mathbb{R}\\). For example let us plot the curve \\(\\gamma\\) implicitly defined by \\[\nf(x,y) =( 3 x^2 - y^2 )^2 \\ y^2  -  (x^2 + y^2 )^4\n\\] for \\(-1 \\leq x,y \\leq 1\\). First, we need a way to generate a grid in \\(\\mathbb{R}^2\\) so that we can evaluate \\(f\\) on such grid. To illustrate how to do this, let us generate a grid of spacing 1 in the 2D square \\([0,4]^2\\). The goal is to obtain the 5 x 5 matrix of coordinates \\[\nA = \\left(\n\\begin{matrix}\n(0,0) &  (1,0)  &  (2,0) & (3,0) & (4,0) \\\\\n(0,1) &  (1,1)  &  (2,1) & (3,1) & (4,1) \\\\\n(0,2) &  (1,2)  &  (2,2) & (2,3) & (2,4) \\\\\n(0,3) &  (1,3)  &  (2,3) & (3,3) & (3,4) \\\\\n(0,4) &  (1,4)  &  (2,4) & (3,4) & (4,4) \\\\\n\\end{matrix}\n\\right)    \n\\] which corresponds to the grid of points\n\n\n\n\n\nFigure 2.1: The 5 x 5 grid corresponding to the matrix A\n\n\n\n\nTo achieve this, first generate x and y coordinates using\nx = np.linspace(0, 4, 5)\ny = np.linspace(0, 4, 5)\nThis generates coordinates \\[\nx = [0, 1, 2, 3, 4] \\,, \\quad  y = [0, 1, 2, 3, 4] \\,.\n\\] We then need to obtain two matrices \\(X\\) and \\(Y\\): one for the \\(x\\) coordinates in \\(A\\), and one for the \\(y\\) coordinates in \\(A\\). This can be achieved with the code\nX[0,0] = 0 \nX[0,1] = 1\nX[0,2] = 2\nX[0,3] = 3\nX[0,4] = 4\nX[1,0] = 0\nX[1,1] = 1\n...\nx[4,3] = 3\nx[4,4] = 4\nand similarly for \\(Y\\). The output would be the two matrices \\(X\\) and \\(Y\\) \\[\nX = \\left(\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n\\end{matrix}\n\\right)   \\,, \\quad\nY =\n\\left(\n\\begin{matrix}\n0 &  0 &  0 & 0 & 0 \\\\\n1 &  1 &  1 & 1 & 1 \\\\\n2 &  2 &  2 & 2 & 2 \\\\\n3 &  3 &  3 & 3 & 3 \\\\\n4 &  4 &  4 & 4 & 4 \\\\\n\\end{matrix}\n\\right)   \n\\]\nIf now we plot \\(X\\) against \\(Y\\) via the command\nplt.plot(X, Y, 'k.')\nwe obtain Figure 2.1. In the above command the style 'k.' represents black dots. This procedure would be impossible with large vectors. Thankfully there is a function in numpy doing exactly what we need: np.meshgrid.\n\n# Demonstrating np.meshgrid\n\nimport numpy as np\n\n# Generating x and y coordinates\nxlist = np.linspace(0, 4, 5)\nylist = np.linspace(0, 4, 5)\n\n# Generating grid X, Y\nX, Y = np.meshgrid(xlist, ylist)\n\n# Printing the matrices X and Y\n# np.array2string is only needed to align outputs\nprint('X =', np.array2string(X, prefix='X= '))\nprint('\\n')  \nprint('Y =', np.array2string(Y, prefix='Y= '))\n\nX = [[0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]]\n\n\nY = [[0. 0. 0. 0. 0.]\n    [1. 1. 1. 1. 1.]\n    [2. 2. 2. 2. 2.]\n    [3. 3. 3. 3. 3.]\n    [4. 4. 4. 4. 4.]]\n\n\nNow that we have our grid, we can evaluate the function \\(f\\) on it. This is simply done with the command\nZ =((3*(X**2) - Y**2)**2)*(Y**2) - (X**2 + Y**2)**4 \nThis will return the matrix \\(Z\\) containing the values \\(f(x_i,y_i)\\) for all \\((x_i,y_i)\\) in the grid \\([X,Y]\\). We are now interested in plotting the points in the grid \\([X,Y]\\) for which \\(Z\\) is zero. This is achieved with the command\nplt.contour(X, Y, Z, [0])\nPutting the above observations together, we have the code for plotting the curve \\(f=0\\) for \\(-1 \\leq x,y \\leq 1\\).\n\n# Plotting f=0\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generates coordinates and grid\nxlist = np.linspace(-1, 1, 5000)\nylist = np.linspace(-1, 1, 5000)\nX, Y = np.meshgrid(xlist, ylist)\n\n# Computes f\nZ =((3*(X**2) - Y**2)**2)*(Y**2) - (X**2 + Y**2)**4 \n\n# Creates figure object\nplt.figure(figsize = (4,4))\n\n# Plots level set Z = 0\nplt.contour(X, Y, Z, [0])\n\n# Set axes labels\nplt.xlabel(\"x-axis\", fontsize = 15)\nplt.ylabel(\"y-axis\", fontsize = 15)\n\n# Shows plot\nplt.show()\n\n\n\n\nPlot of the curve defined by f=0"
  },
  {
    "objectID": "sections/chap_1_1.html#curves-in-3d",
    "href": "sections/chap_1_1.html#curves-in-3d",
    "title": "2  Plotting curves",
    "section": "2.3 Curves in 3D",
    "text": "2.3 Curves in 3D\nPlotting in 3D with matplotlib requires the mplot3d toolkit, see here for documentation. Therefore our first lines will always be\n# Packages for 3D plots\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\nWe can now generate empty 3D axes\n\n# Generates and plots empty 3D axes\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Creates figure object\nfig = plt.figure(figsize = (4,4))\n\n# Creates 3D axes object\nax = plt.axes(projection = '3d')\n\n# Shows the plot\nplt.show()\n\n\n\n\nIn the above code fig is a figure object, while ax is an axes object. In practice, the figure object contains the axes objects, and the actual plot information will be contained in axes. If you want multiple plots in the figure container, you should use the command\nax = fig.add_subplot(nrows = m, ncols = n, pos = k)\nThis generates an axes object ax in position k with respect to a m x n grid of plots in the container figure. For example we can create a 3 x 2 grid of empty 3D axes as follows\n\n# Generates 3 x 2 empty 3D axes\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Creates container figure object\nfig = plt.figure(figsize = (6,8))\n\n# Creates 6 empty 3D axes objects\nax1 = fig.add_subplot(3, 2, 1, projection = '3d')\nax2 = fig.add_subplot(3, 2, 2, projection = '3d')\nax3 = fig.add_subplot(3, 2, 3, projection = '3d')\nax4 = fig.add_subplot(3, 2, 4, projection = '3d')\nax5 = fig.add_subplot(3, 2, 5, projection = '3d')\nax6 = fig.add_subplot(3, 2, 6, projection = '3d')\n\n# Shows the plot\nplt.show()\n\n\n\n\nWe are now ready to plot a 3D parametric curve \\(\\gamma \\colon (a,b) \\to \\mathbb{R}^3\\) of the form \\[\n\\gamma(t) = (x(t), y(t), z(t))\n\\] with the code\n# Code to plot 3D curve\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure and 3D axes\nfig = plt.figure(figsize = (size1,size2))\nax = plt.axes(projection = '3d')\n\n# Plots grid\nax.grid(True)\n\n# Divides time interval (a,b)\n# into n parts and saves them in array t\nt = np.linspace(a, b, n)\n\n# Computes the curve gamma on array t\n# for given functions x(t), y(t), z(t)\nx = x(t) \ny = y(t)\nz = z(t)\n\n# Plots gamma\nax.plot3D(x, y, z)\n\n# Setting title for plot\nax.set_title('3D Plot of gamma')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad = 'p')\nax.set_ylabel('y', labelpad = 'p')\nax.set_zlabel('z', labelpad = 'p')\n\n# Shows the plot\nplt.show()\nFor example we can use the above code to plot the Helix \\[\nx(t) = \\cos(t) \\,, \\quad\ny(t) = \\sin(t) \\,, \\quad\nz(t) = t\n\\tag{2.3}\\] for \\(t \\in [0,6\\pi]\\).\n\n# Plotting 3D Helix\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure and 3D axes\nfig = plt.figure(figsize = (4,4))\nax = plt.axes(projection = '3d')\n\n# Plots grid\nax.grid(True)\n\n# Divides time interval (0,6pi) in 100 parts \nt = np.linspace(0, 6*np.pi, 100)\n\n# Computes Helix\nx = np.cos(t) \ny = np.sin(t)\nz = t\n\n# Plots Helix - We added some styling\nax.plot3D(x, y, z, color = \"deeppink\", linewidth = 2)\n\n# Setting title for plot\nax.set_title('3D Plot of Helix')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad = 20)\nax.set_ylabel('y', labelpad = 20)\nax.set_zlabel('z', labelpad = 20)\n\n# Shows the plot\nplt.show()\n\n\n\n\nWe can also change the viewing angle for a 3D plot store in ax. This is done via\nax.view_init(elev = e, azim = a)\nwhich displays the 3D axes with an elevation angle elev of e degrees and an azimuthal angle azim of a degrees. In other words, the 3D plot will be rotated by e degrees above the xy-plane and by a degrees around the z-axis. For example, let us plot the helix with 2 viewing angles. Note that we generate 2 sets of axes with the add_subplot command discussed above.\n\n# Plotting 3D Helix\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object\nfig = plt.figure(figsize = (4,4))\n\n# Generates 2 sets of 3D axes\nax1 = fig.add_subplot(1, 2, 1, projection = '3d')\nax2 = fig.add_subplot(1, 2, 2, projection = '3d')\n\n# We will not show a grid this time\nax1.grid(False)\nax2.grid(False)\n\n# Divides time interval (0,6pi) in 100 parts \nt = np.linspace(0, 6*np.pi, 100)\n\n# Computes Helix\nx = np.cos(t) \ny = np.sin(t)\nz = t\n\n# Plots Helix on both axes\nax1.plot3D(x, y, z, color = \"deeppink\", linewidth = 1.5)\nax2.plot3D(x, y, z, color = \"deeppink\", linewidth = 1.5)\n\n# Setting title for plots\nax1.set_title('Helix from above')\nax2.set_title('Helix from side')\n\n# Changing viewing angle of ax1\n# View from above has elev = 90 and azim = 0\nax1.view_init(elev = 90, azim = 0)\n\n# Changing viewing angle of ax2\n# View from side has elev = 0 and azim = 0\nax2.view_init(elev = 0, azim = 0)\n\n# Shows the plot\nplt.show()"
  },
  {
    "objectID": "sections/chap_1_1.html#sec-plot-2d-interactive",
    "href": "sections/chap_1_1.html#sec-plot-2d-interactive",
    "title": "2  Plotting curves",
    "section": "2.4 Interactive plots",
    "text": "2.4 Interactive plots\nMatplotlib produces beautiful static plots; however it lacks built in interactivity. For this reason I would also like to show you how to plot curves with Plotly, a very popular Python graphic library which has built in interactivity. Documentation for Plotly and lots of examples can be found here.\n\n2.4.1 2D Plots\nSay we want to plot the 2D curve \\(\\gamma \\colon (a,b) \\to \\mathbb{R}^2\\) parametrized by \\[\n\\gamma(t) = ( x(t) , y(t) ) \\,.\n\\] The Plotly module needed is called graph_objects, usually imported as go. The function for line plots is called Scatter. For documentation and examples see link. The code for plotting \\(\\gamma\\) is as follows.\n# Plotting gamma 2D\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Compute times grid by dividing (a,b) in \n# n equal parts\nt = np.linspace(a, b, n)\n\n# Compute the parametric curve gamma\n# for given functions x(t) and y(t)\nx = x(t)\ny = y(t)\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\ndata = go.Scatter(x = x, y = y, mode = 'lines', name = 'gamma')\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Display the figure\nfig.show()\nSome comments about the functions called above:\n\ngo.Figure: generates an empty Plotly figure\ngo.Scatter: generates the actual plot. By default a scatter plot is produced. To obtain linear interpolation of the points, set mode = 'lines'. You can also label the plot with name = \"string\"\nadd_trace: adds a plot to a figure\nshow: displays a figure\n\nAs an example, let us plot the Fermat’s Spiral defined at 2.2. Compared to the above code, we also add a bit of styling.\n\n# Plotting Fermat's Spiral\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Compute times grid by dividing (0,50) in \n# 500 equal parts\nt = np.linspace(0, 50, 500)\n\n# Computes Fermat's Spiral\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\ndata = go.Scatter(x = x, y = y, mode = 'lines', name = 'gamma')\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Here we start with the styling options\n# First we set a figure title\nfig.update_layout(title_text = \"Plotting Fermat's Spiral with Plotly\")\n\n# Adjust figure size\nfig.update_layout(autosize = False, width = 600, height = 600)\n\n# Change background canvas color\nfig.update_layout(paper_bgcolor = \"snow\")\n\n# Axes styling: adding title and ticks positions \nfig.update_layout(\nxaxis=dict(\n        title_text=\"X-axis Title\",\n        titlefont=dict(size=20),\n        tickvals=[-6,-4,-2,0,2,4,6],\n        ), \n\nyaxis=dict(\n        title_text=\"Y-axis Title\",\n        titlefont=dict(size=20),\n        tickvals=[-6,-4,-2,0,2,4,6],\n        )\n)\n\n# Display the figure\nfig.show()\n\n\n                                                \n\n\nAs you can examine by moving the mouse pointer, the above plot is interactive. Note that the style customizations could be listed in a single call of the function update_layout. There are also pretty buit-in themes available, see here. The layout can be specified with the command\nfig.update_layout(template = template_name)\nwhere template_name can be \"plotly\", \"plotly_white\", \"plotly_dark\", \"ggplot2\", \"seaborn\", \"simple_white“.\n\n\n2.4.2 3D Plots\nWe now want to plot a 3D curve \\(\\gamma \\colon (a,b) \\to \\mathbb{R}^3\\) parametrized by \\[\n\\gamma(t) = ( x(t) , y(t) , z(t)) \\,.\n\\] Again we use the Plotly module graph_objects, imported as go. The function for 3D line plots is called Scatter3d, and documentation and examples can be found at link. The code for plotting \\(\\gamma\\) is as follows.\n# Plotting gamma 3D\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Compute times grid by dividing (a,b) in \n# n equal parts\nt = np.linspace(a, b, n)\n\n# Compute the parametric curve gamma\n# for given functions x(t), y(t), z(t)\nx = x(t)\ny = y(t)\nz = z(t)\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\ndata = go.Scatter3d(x = x, y = y, z = z, mode = 'lines', name = 'gamma')\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Display the figure\nfig.show()\nThe functions go.Figure, add_trace and show appearing above are described in the previous Section. The new addition is go.Scatter3d, which generates a 3D scatter plot of the points stored in the array [x,y,z]. Setting mode = 'lines' results in a linear interpolation of such points. As before, the curve can be labeled by setting name = \"string\".\nAs an example, we plot the 3D Helix defined at 2.3. We also add some styling. We can also use the same pre-defined templates descirbed for go.Scatter in the previous section, see here for official documentation.\n\n# Plotting 3D Helix\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Divides time interval (0,6pi) in 100 parts \nt = np.linspace(0, 6*np.pi, 100)\n\n# Computes Helix\nx = np.cos(t) \ny = np.sin(t)\nz = t\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\n# We add options for the line width and color\ndata = go.Scatter3d(\n    x = x, y = y, z = z, \n    mode = 'lines', name = 'gamma', \n    line = dict(width = 10, color = \"darkblue\")\n    )\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Here we start with the styling options\n# First we set a figure title\nfig.update_layout(title_text = \"Plotting 3D Helix with Plotly\")\n\n# Adjust figure size\nfig.update_layout(\n    autosize = False, \n    width = 600, \n    height = 600\n    )\n\n# Set pre-defined template\nfig.update_layout(template = \"seaborn\")\n\n# Options for curve line style\n\n\n# Display the figure\nfig.show()\n\n\n                                                \n\n\nThe above plot is interactive: you can pan arond by dragging the pointer. Once again, the style customizations could be listed in a single call of the function update_layout."
  },
  {
    "objectID": "sections/chap_1_1.html#footnotes",
    "href": "sections/chap_1_1.html#footnotes",
    "title": "2  Plotting curves",
    "section": "",
    "text": "The command plt.show() can be omitted if working in Jupyter Notebook, as it is called by default.↩︎"
  },
  {
    "objectID": "sections/chap_1_2.html#plots-with-matplotlib",
    "href": "sections/chap_1_2.html#plots-with-matplotlib",
    "title": "3  Plotting surfaces",
    "section": "3.1 Plots with Matplotlib",
    "text": "3.1 Plots with Matplotlib\nI will take for granted all the commands explained in Chapter 2. Suppose we want to plot a surface \\(S\\) which is defined by the parametric equations \\[\nx = x(u,v) \\,, \\quad\ny = y(u,v) \\,, \\quad\nz = z(u,v)\n\\] for \\(u \\in (a,b)\\) and \\(v \\in (c,d)\\). This can be done via the function called plot_surface contained in the mplot3d Toolkit. This function works as follows: first we generate a mesh-grid \\([U,V]\\) from the coordinates \\((u,v)\\) via the command\n[U, V] = np.meshgrid(u, v)\nThen we compute the parametric surface on the mesh\nx = x (U, V)\ny = y (U, V)\nz = z (U, V)\nFinally we can plot the surface with the command\nplt.plot_surface(x, y, z)\nThe complete code looks as follows.\n# Plotting surface S\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size m x n\nfig = plt.figure(figsize = (m,n))\n\n# Generates 3D axes\nax = plt.axes(projection = '3d')\n\n# Shows axes grid\nax.grid(True)\n\n# Generates coordinates u and v\n# by dividing the interval (a,b) in n parts\n# and the interval (c,d) in m parts\nu = np.linspace(a, b, m)\nv = np.linspace(c, d, n)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes S given the functions x, y, z\n# on the grid [U,V]\nx = x(U,V)\ny = y(U,V)\nz = z(U,V)\n\n# Plots the surface S\nax.plot_surface(x, y, z)\n\n# Setting plot title \nax.set_title('The surface S')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad=10)\nax.set_ylabel('y', labelpad=10)\nax.set_zlabel('z', labelpad=10)\n\n# Setting viewing angle\nax.view_init(elev = e, azim = a)\n\n# Showing the plot\nplt.show()\nFor example let us plot a cone described parametrically by: \\[\nx = u \\cos(v) \\,, \\quad\ny = u \\sin(v) \\,, \\quad\nz = u\n\\] for \\(u \\in (0,1)\\) and \\(v \\in (0,2\\pi)\\). We adapt the above code:\n\n# Plotting a cone\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size 4 x 4\nfig = plt.figure(figsize = (4,4))\n\n# Generates 3D axes\nax = plt.axes(projection = '3d')\n\n# Shows axes grid\nax.grid(True)\n\n# Generates coordinates u and v by dividing\n# the intervals (0,1) and (0,2pi) in 100 parts\nu = np.linspace(0, 1, 100)\nv = np.linspace(0, 2*np.pi, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the surface on grid [U,V]\nx = U * np.cos(V)\ny = U * np.sin(V)\nz = U\n\n# Plots the cone\nax.plot_surface(x, y, z)\n\n# Setting plot title \nax.set_title('Plot of a cone')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad=10)\nax.set_ylabel('y', labelpad=10)\nax.set_zlabel('z', labelpad=10)\n\n# Setting viewing angle\nax.view_init(elev = 25, azim = 45)\n\n# Showing the plot\nplt.show()\n\n\n\n\nAs discussed in Chapter 2, we can have multiple plots in the same figure. For example let us plot the torus viewed from 2 angles. The parametric equations are: \\[\n\\begin{aligned}\nx & = (R + r \\cos(u)) \\cos(v)  \\\\\ny & = (R + r \\cos(u)) \\sin(v)  \\\\\nz & = r \\sin(u)\n\\end{aligned}\n\\] for \\(u, v \\in (0,2\\pi)\\) and with\n\n\\(R\\) distance from the center of the tube to the center of the torus\n\\(r\\) radius of the tube\n\n\n# Plotting torus seen from 2 angles\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size 9 x 5\nfig = plt.figure(figsize = (9,5))\n\n# Generates 2 sets of 3D axes\nax1 = fig.add_subplot(1, 2, 1, projection = '3d')\nax2 = fig.add_subplot(1, 2, 2, projection = '3d')\n\n# Shows axes grid\nax1.grid(True)\nax2.grid(True)\n\n# Generates coordinates u and v by dividing\n# the interval (0,2pi) in 100 parts\nu = np.linspace(0, 2*np.pi, 100)\nv = np.linspace(0, 2*np.pi, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the torus on grid [U,V]\n# with radii r = 1 and R = 2\nR = 2\nr = 1\n\nx = (R + r * np.cos(U)) * np.cos(V)\ny = (R + r * np.cos(U)) * np.sin(V)\nz = r * np.sin(U)\n\n# Plots the torus on both axes\nax1.plot_surface(x, y, z, rstride = 5, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\nax2.plot_surface(x, y, z, rstride = 5, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\n# Setting plot titles \nax1.set_title('Torus')\nax2.set_title('Torus from above')\n\n# Setting range for z axis in ax1\nax1.set_zlim(-3,3)\n\n# Setting viewing angles\nax1.view_init(elev = 35, azim = 45)\nax2.view_init(elev = 90, azim = 0)\n\n# Showing the plot\nplt.show()\n\n\n\n\nNotice that we have added some customization to the plot_surface command. Namely, we have set the color of the figure with color = 'dimgray' and of the edges with edgecolors = 'snow'. Moreover the commands rstride and cstride set the number of wires you see in the plot. More precisely, they set by how much the data in the mesh \\([U,V]\\) is downsampled in each direction, where rstride sets the row direction, and cstride sets the column direction. On the torus this is a bit difficult to visualize, due to the fact that \\([U,V]\\) represents angular coordinates. To appreciate the effect, we can plot for example the paraboiloid \\[\n\\begin{aligned}\nx & = u  \\\\\ny & = v  \\\\\nz & = - u^2 - v^2\n\\end{aligned}\n\\] for \\(u,v \\in [-1,1]\\).\n\n# Showing the effect of rstride and cstride\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size 6 x 6\nfig = plt.figure(figsize = (6,6))\n\n# Generates 2 sets of 3D axes\nax1 = fig.add_subplot(2, 2, 1, projection = '3d')\nax2 = fig.add_subplot(2, 2, 2, projection = '3d')\nax3 = fig.add_subplot(2, 2, 3, projection = '3d')\nax4 = fig.add_subplot(2, 2, 4, projection = '3d')\n\n# Generates coordinates u and v by dividing\n# the interval (-1,1) in 100 parts\nu = np.linspace(-1, 1, 100)\nv = np.linspace(-1, 1, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the paraboloid on grid [U,V]\nx = U\ny = V\nz = - U**2 - V**2\n\n# Plots the paraboloid on the 4 axes\n# but with different stride settings\nax1.plot_surface(x, y, z, rstride = 5, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\nax2.plot_surface(x, y, z, rstride = 5, cstride = 20, color = 'dimgray', edgecolors = 'snow')\n\nax3.plot_surface(x, y, z, rstride = 20, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\nax4.plot_surface(x, y, z, rstride = 10, cstride = 10, color = 'dimgray', edgecolors = 'snow')\n\n# Setting plot titles \nax1.set_title('rstride = 5, cstride = 5')\nax2.set_title('rstride = 5, cstride = 20')\nax3.set_title('rstride = 20, cstride = 5')\nax4.set_title('rstride = 10, cstride = 10')\n\n# We do not plot axes, to get cleaner pictures\nax1.axis('off')\nax2.axis('off')\nax3.axis('off')\nax4.axis('off')\n\n# Showing the plot\nplt.show()\n\n\n\n\nIn this case our mesh is 100 x 100, since u and v both have 100 components. Therefore setting rstride and cstride to 5 implies that each row and column of the mesh is sampled one time every 5 elements, for a total of \\[\n100/5 = 20\n\\] samples in each direction. This is why in the first picture you see a 20 x 20 grid. If instead one sets rstride and cstride to 10, then each row and column of the mesh is sampled one time every 10 elements, for a total of \\[\n100/10 = 10\n\\] samples in each direction. This is why in the fourth figure you see a 10x10 grid."
  },
  {
    "objectID": "sections/chap_1_2.html#plots-with-plotly",
    "href": "sections/chap_1_2.html#plots-with-plotly",
    "title": "3  Plotting surfaces",
    "section": "3.2 Plots with Plotly",
    "text": "3.2 Plots with Plotly\nAs done in Section 2.4, we now see how to use Plotly to generate an interactive 3D plot of a surface. This can be done by means of functions contained in the Plotly module graph_objects, usually imported as go. Specifically, we will use the function go.Surface. The code will look similar to the one used to plot surfaces with matplotlib:\n\ngenerate meshgrid on which to compute the parametric surface,\nstore such surface in the numpy array [x,y,z],\npass the array [x,y,z] to go.Surface to produce the plot.\n\nThe full code is below.\n\n# Plotting a Torus with Plotly\n\n# Import \"numpy\" and the \"graph_objects\" module from Plotly\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Generates coordinates u and v by dividing\n# the interval (0,2pi) in 100 parts\nu = np.linspace(0, 2*np.pi, 100)\nv = np.linspace(0, 2*np.pi, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the torus on grid [U,V]\n# with radii r = 1 and R = 2\nR = 2\nr = 1\n\nx = (R + r * np.cos(U)) * np.cos(V)\ny = (R + r * np.cos(U)) * np.sin(V)\nz = r * np.sin(U)\n\n# Generate and empty figure object with Plotly\n# and saves it to the variable called \"fig\"\nfig = go.Figure()\n\n# Plot the torus with go.Surface and store it\n# in the variable \"data\". We also do now show the\n# plot scale, and set the color map to \"teal\"\ndata = go.Surface(\n    x = x , y = y, z = z, \n    showscale = False, \n    colorscale='teal'\n    )\n\n# Add the plot stored in \"data\" to the figure \"fig\"\n# This is done with the command add_trace\nfig.add_trace(data)\n\n# Set the title of the figure in \"fig\"\nfig.update_layout(title_text=\"Plotting a Torus with Plotly\")\n\n# Show the figure\nfig.show()\n\n\n                                                \n\n\nYou can rotate the above image by clicking on it and dragging the cursor. To further customize your plots, you can check out the documentation of go.Surface at this link. For example, note that we have set the colormap to teal: for all the pretty colorscales available in Plotly, see this page.\nOne could go even fancier and use the tri-surf plots in Plotly. This is done with the function create_trisurf contained in the module figure_factory of Plotly, usually imported as ff. The documentation can be found here. We also need to import the Python library scipy, which we use to generate a Delaunay triangulation for our plot. Let us for example plot the torus.\n\n# Plotting Torus with tri-surf\n\n# Importing libraries\nimport numpy as np\nimport plotly.figure_factory as ff\nfrom scipy.spatial import Delaunay\n\n# Generates coordinates u and v by dividing\n# the interval (0,2pi) in 100 parts\nu = np.linspace(0, 2*np.pi, 20)\nv = np.linspace(0, 2*np.pi, 20)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Collapse meshes to 1D array\n# This is needed for create_trisurf \nU = U.flatten()\nV = V.flatten()\n\n# Computes the torus on grid [U,V]\n# with radii r = 1 and R = 2\nR = 2\nr = 1\n\nx = (R + r * np.cos(U)) * np.cos(V)\ny = (R + r * np.cos(U)) * np.sin(V)\nz = r * np.sin(U)\n\n# Generate Delaunay triangulation\npoints2D = np.vstack([U,V]).T\ntri = Delaunay(points2D)\nsimplices = tri.simplices\n\n# Plot the Torus\nfig = ff.create_trisurf(\n    x=x, y=y, z=z,\n    colormap = \"Portland\",\n    simplices=simplices,\n    title=\"Torus with tri-surf\", \n    aspectratio=dict(x=1, y=1, z=0.3),\n    show_colorbar = False\n    )\n\n# Adjust figure size\nfig.update_layout(autosize = False, width = 700, height = 700)\n\n# Show the figure\nfig.show()\n\n\n                                                \n\n\nAgain, the above figure is interactive. Try rotating the torus with the pointer."
  },
  {
    "objectID": "sections/license.html#reuse",
    "href": "sections/license.html#reuse",
    "title": "License",
    "section": "Reuse",
    "text": "Reuse\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License"
  },
  {
    "objectID": "sections/license.html#citation",
    "href": "sections/license.html#citation",
    "title": "License",
    "section": "Citation",
    "text": "Citation\nFor attribution, please cite this work as:\n\nFanzon, Silvio. (2023). Lecture Notes on Differential Geometry.\nhttps://www.silviofanzon.com/2023-Differential-Geometry-Notes/\n\nBibTex citation:\n@electronic{Danzon-Diff-Geom-2023,\n    author = {Fanzon, Silvio},\n    title = {Lecture Notes on Differential Geometry},\n    url = {https://www.silviofanzon.com/2023-Differential-Geometry-Notes/},\n    year = {2023}}"
  },
  {
    "objectID": "sections/references.html",
    "href": "sections/references.html",
    "title": "References",
    "section": "",
    "text": "[1] R.\nJohansson, Numerical python. Scientific computing and data science\napplications with numpy, SciPy and matplotlib, Second Edition, Apress,\n2019.\n\n\n[2] Q.\nKong, T. Siauw, A. Bayen, Python programming and numerical methods,\nAcademic Press, 2020.\n\n\n[3] C.\nBär, Elementary differential geometry, Cambridge University Press,\n2010.\n\n\n[4] M.P. do Carmo, Differential geometry of curves\nand surfaces, Second Edition, Dover Books on Mathematics, 2017.\n\n\n[5] A.\nPressley, Elementary differential geometry, Second Edition, Springer,\n2010.\n\n\n[6] V.A. Zorich, Mathematical analysis II, Second\nEdition, Springer, 2016.\n\n\n[7] V.A. Zorich, Mathematical analysis i, Second\nEdition, Springer, 2015."
  }
]