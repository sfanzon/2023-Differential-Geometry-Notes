[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Differential Geometry",
    "section": "",
    "text": "Welcome\nThese are the Lecture Notes of Differential Geometry 661955 for T1 2023/24 at the University of Hull. We will study curves and surfaces in \\(\\mathbb{R}^3\\). I will follow these lecture notes during the course. If you have any question or find any typo, please email me at\nUp to date information about the course, Tutorials and Homework will be published on the University of Hull Canvas Website\nand on the Course Webpage hosted on my website"
  },
  {
    "objectID": "index.html#digital-notes",
    "href": "index.html#digital-notes",
    "title": "Differential Geometry",
    "section": "Digital Notes",
    "text": "Digital Notes\nFeatures of these digital notes:\n\nNavigation bar is available on the left\nA search function is available on the top-right\nYou can toggle dark mode on the top-right\nA pdf version of these notes is available to download on the top-right"
  },
  {
    "objectID": "index.html#readings",
    "href": "index.html#readings",
    "title": "Differential Geometry",
    "section": "Readings",
    "text": "Readings\nThe main textbook of the course is Pressley (Pressley 2010). Other interesting readings are the books by do Carmo (Carmo 2017) and Bär (Bär 2010). I will assume some knowledge from Analysis and Linear Algebra. A good place to revise these topics are the books by Zorich (Zorich 2015, 2016)."
  },
  {
    "objectID": "index.html#visualization",
    "href": "index.html#visualization",
    "title": "Differential Geometry",
    "section": "Visualization",
    "text": "Visualization\nIt is important to visualize the geometrical objects and concepts we are going to talk about in this course. I will show basic Python code to plot curves and surfaces. This part of the course is not required for the final examination. If you want to have fun plotting with Pyhton, I recommend installation through Anaconda or Miniconda. The actual coding can then be done through Jupyter Notebook. Good references for scientific Python programming are (Johansson 2019; Kong, Siauw, and Bayen 2020).\nIf you do not want to mess around with Python, you can still visualize pretty much everything we will do in this course using the excellent online 3D grapher tool CalcPlot3D. To understand how it works, please refer to the help manual or to the short video introduction.\n\n\n\n\n\n\nImportant\n\n\n\nYou are not expected to purchase any of the above books. These lecture notes will cover 100% of the topics you are expected to known in order to excel in the final exam.\n\n\n\n\n\n\nBär, Christian. 2010. Elementary Differential Geometry. Cambridge University Press.\n\n\nCarmo, Manfredo P. do. 2017. Differential Geometry of Curves and Surfaces. Second Edition. Dover Books on Mathematics.\n\n\nJohansson, Robert. 2019. Numerical Python. Scientific Computing and Data Science Applications with Numpy, SciPy and Matplotlib. Second Edition. Apress.\n\n\nKong, Qingkai, Timmy Siauw, and Alexandre Bayen. 2020. Python Programming and Numerical Methods. Academic Press.\n\n\nPressley, Andrew. 2010. Elementary Differential Geometry. Second Edition. Springer.\n\n\nZorich, Vladimir A. 2015. Mathematical Analysis i. Second Edition. Springer.\n\n\n———. 2016. Mathematical Analysis II. Second Edition. Springer."
  },
  {
    "objectID": "sections/chap_1.html#parametrized-curves",
    "href": "sections/chap_1.html#parametrized-curves",
    "title": "1  Curves",
    "section": "1.1 Parametrized curves",
    "text": "1.1 Parametrized curves\nRather than Cartesian equations, a more useful way of thinking about curves is viewing them as the path traced out by a moving point. If \\(\\g(t)\\) represents the position a point in \\(\\R^n\\) at time \\(t\\), the whole curve can be identified by the function \\[\n\\g \\ \\colon \\R \\to \\R^n \\,, \\,\\,\\, \\g = \\g(t) \\,.\n\\]\nThis motivates the following definition of parametrized curve, which will be our main definition of curve.\n\nDefinition 1: Parametrized curveA parametrized curve in \\(\\R^n\\) is a function \\[\n\\g \\ \\colon  (a,b) \\to \\R^n \\,.\n\\]\nwhere\n\\[\n- \\infty \\leq a &lt; b \\leq \\infty \\,.\n\\]\n\n\nA few remarks:\n\nThe symbol \\((a,b)\\) denotes an open interval \\[\n(a,b) = \\{ t \\in \\R \\ \\colon \\ a &lt; t &lt; b \\}\\,.\n\\]\nThe requirement that \\[\n-\\infty \\leq a &lt; b \\leq \\infty\n\\] means that the interval \\((a,b)\\) is possibly unbounded.\nFor each \\(t \\in (a,b)\\) the quantity \\(\\g(t)\\) is a vector in \\(\\R^n\\).\nThe components of \\(\\g(t)\\) are denoted by \\[\n\\g(t) = ( \\gamma_1(t), \\ldots, \\gamma_n(t) ) \\,,\n\\] where the components are functions \\[\n\\gamma_i \\ \\colon (a,b) \\to \\R \\,,\n\\] for all \\(i = 1, \\ldots, n\\)."
  },
  {
    "objectID": "sections/chap_1.html#parametrizing-cartesian-curves",
    "href": "sections/chap_1.html#parametrizing-cartesian-curves",
    "title": "1  Curves",
    "section": "1.2 Parametrizing cartesian curves",
    "text": "1.2 Parametrizing cartesian curves\nAt the start we said that examples of curves in \\(\\R^2\\) were the straight line, the hyperbole and the circle, with equations \\[\ny = 2x + 1\\,, \\quad y = e^x  \\,, \\quad  x^2 + y^2 = 1 \\,.\n\\] We saw that these can be represented by Cartesian equations \\[\nf(x,y) = c\n\\] for some function \\(f \\ \\colon \\R^2 \\to \\R\\) and value \\(c \\in \\R\\). Curves that can be represented in this way are called level curves. Let us give a precise definition.\n\nDefinition 2: Level curveA level curve in \\(\\R^n\\) is a set \\(C \\subset \\R^n\\) which can be described as \\[\nC= \\{  (x_1,\\ldots,x_n) \\in \\R^n \\ \\colon \\ f(x_1,\\ldots,x_n) = c   \\}\n\\] for some given function \\[\nf \\ \\colon \\R^n \\to \\R\n\\] and value \\[\nc \\in \\R \\,.\n\\]\n\n\nWe now want to represent level curves by means of parametrizations.\n\nDefinition 3Suppose given a level curve \\(C \\subset \\R^n\\). We say that a curve \\[\n\\g \\ \\colon (a,b) \\to \\R^n\n\\] parametrizes \\(C\\) if \\[\nC = \\{ (\\g_1(t), \\ldots, \\g_n(t) ) \\ \\colon \\ t \\in (a,b)   \\} \\,.\n\\]\n\n\n\nQuestionCan we represent the level curves we saw above by means of a parametrization \\(\\g\\)?\n\n\nThe answer is YES, as shown in the following examples.\n\nExample 4: Parametrizing the straight lineThe straight line \\[\ny = 2x + 1\n\\]\nis a level curve with \\[\nC = \\{ (x,y) \\in \\R^2 \\ \\colon \\  f(x,y) = c  \\} \\,,\n\\] where \\[\nf(x,y) := y -2x \\,, \\quad c :=1 \\,.\n\\]\nHow do we represent \\(C\\) as a parametrized curve \\(\\g\\)? We know that the curve is 2D, therefore we need to find a function \\[\n\\g \\ \\colon  (a,b) \\to \\R^2\n\\] with componenets \\[\n\\g(t) = (\\gamma_1(t),\\gamma_2(t)) \\, .\n\\] The curve \\(\\g\\) needs to be chosen so that it parametrizes the set \\(C\\), in the sense that \\[\nC = \\{ (\\g_1(t), \\g_2(t)) \\ \\colon \\ t \\in (a,b)  \\} \\,.\n\\tag{1.1}\\] Thus we need to have \\[\n(x,y) = (\\g_1,\\g_2) \\,.\n\\tag{1.2}\\] How do we define such \\(\\g\\)? Note that the points \\((x,y)\\) in \\(C\\) satisfy \\[\n(x,y) \\in C \\iff  y = 2x +1 \\,.\n\\] Therefore, using (1.2), we have that \\[\n\\g_1 = x \\,, \\quad \\g_2 = y = 2x + 1\n\\] from which we deduce that \\(\\g\\) must satisfy \\[\n\\g_2(t) = 2 \\g_1(t) + 1\n\\tag{1.3}\\] for all \\(t \\in (a,b)\\). We can then choose \\[\n\\g_1(t) := t \\,,\n\\] and from (1.3) we deduce that \\[\n\\g_2 (t) = 2 t + 1 \\,.\n\\] This choice of \\(\\g\\) works: \\[\\begin{align}\nC & = \\{ (x,2x+1) \\ \\colon \\ x \\in \\R  \\} \\\\\n  & = \\{ (t,2t+1) \\ \\colon \\ - \\infty &lt; t &lt; \\infty  \\} \\\\\n  & = \\{ (\\g_1(t),\\g_2(t)) \\ \\colon \\ - \\infty &lt; t &lt; \\infty  \\} \\,,\n\\end{align}\\] where in the second line we just swapped the symbol \\(x\\) with the symbol \\(t\\). In this case we have to choose the time interval as \\[\n(a,b) = (-\\infty,\\infty) \\,.\n\\] In this way \\(\\g\\) satisfies (1.1) and we have successfully parametrized the straight line \\(C\\).\n\n\n\nRemark 5: Parametrization is not uniqueLet us consider again the straight line \\[\nC = \\{ (x,y) \\in \\R^2 \\ \\colon \\  2x+1 = y \\} \\,.\n\\] We saw that \\(\\g \\colon (-\\infty,\\infty) \\to \\R^2\\) defined by \\[\n\\g(t):=(t,2t+1)\n\\] is a parametrization of \\(C\\). But of course any \\(\\g\\) satisfying \\[\n\\g_2(t) = 2 \\g_1(t) + 1\n\\] would yield a parametrization of \\(C\\). For example one could choose \\[\n\\g_1 (t) = 2t \\,, \\quad \\g_2(t) = 2 \\g_1(t) + 1 = 4t + 1 \\,.\n\\] In general, any time rescaling would work: the curve \\(\\g\\) defined by \\[\n\\g_1 (t) = nt \\,, \\quad \\g_2(t) = 2 \\g_1(t) + 1 = 2nt + 1  \n\\] parametrizes \\(C\\) for all \\(n \\in \\N\\). Hence there are infinitely many parametrizations of \\(C\\).\n\n\n\nExample 6: Parametrizing the circle\nThe circle \\(C\\) is described by all the points \\((x,y) \\in \\R^2\\) such that \\[\nx^2 + y^2 = 1\\,.\n\\] Therefore if we want to find a curve \\[\n\\g = (\\g_1,\\g_2)\n\\] which parametrizes \\(C\\), this has to satisfy \\[\n\\g_1 (t)^2 + \\g_2(t)^2 = 1\n\\tag{1.4}\\] for all \\(t \\in (a,b)\\).\nHow to find such curve? We could proceed as in the previous example, and set \\[\n\\g_1(t):=t \\,.\n\\] Then (1.4) implies \\[\n\\g_2 (t) = \\sqrt{1-t^2}\\,,\n\\] from which we also deduce that \\[\n- 1 \\leq t \\leq 1\n\\] are the only admissible values of \\(t\\). However this curve does not represent the full circle \\(C\\), but only the upper half, as seen in the plot below.\nSimlarly, another solution to (1.4) would be \\(\\g\\) with \\[\n\\g_1(t)=t \\,, \\quad \\g_2 (t) = - \\sqrt{1-t^2}\\,,\n\\] for \\(t \\in [-1,1]\\). However this choice does not parametrize the full circle \\(C\\) either, but only the bottom half, as seen in the plot below.\nHow to represent the whole circle? Recall the trigonometric identity \\[\n\\cos(t)^2 + \\sin(t)^2 = 1\n\\] for all \\(t \\in \\R\\). This suggests to choose \\(\\g\\) as \\[\n\\g_1(t):=\\cos(t)\\,, \\quad \\g_2(t):=\\sin(t)\n\\] for \\(t \\in [0,2\\pi)\\). This way \\(\\g\\) satisfies (1.4), and actually parametrizes \\(C\\), as shown below.\nNote the following:\n\nIf we had chosen \\(t \\in [0,4\\pi]\\) then \\(\\g\\) would have covered \\(C\\) twice.\nIf we had chosen \\(t \\in [0,\\pi]\\), then \\(\\g\\) would have covered the upper semi-circle\nIf we had chosen \\(t \\in [\\pi,2\\pi]\\), then \\(\\g\\) would have covered the lower semi-circle\nSimilarly, we can choose \\(t \\in [\\pi/6, \\pi /2]\\) to cover just a portion of \\(C\\), as shown below.\n\n\n\n\n\n\n\n\nUpper semi-circle\n\n\n\n\n\n\n\n\n\nLower semi-circle\n\n\n\n\n\n\n\n\n\nLower semi-circle\n\n\n\n\n\n\n\n\n\nPlotting a portion of \\(C\\)\n\n\n\n\nFinally we are also able to give a mathematical description of the 3D Helix.\n\nExample 7: Parametrizing the helixThe Helix plotted above can be parametrized by \\[\n\\g \\ \\colon (-\\infty,\\infty) \\to \\R^3\n\\] defined by \\[\n\\g_1(t) = \\cos(t)\\,, \\,\\,\n\\g_2(t) = \\sin(t)\\,, \\,\\,\n\\g_3(t) = t \\,.\n\\] The above equations are in line with our intuition: the helix can be drawn by tracing a circle while at the same time lifting the pencil."
  },
  {
    "objectID": "sections/chap_2.html#sec-plot-2d-curves",
    "href": "sections/chap_2.html#sec-plot-2d-curves",
    "title": "2  Curves in Python",
    "section": "2.1 Curves in 2D",
    "text": "2.1 Curves in 2D\nSuppose we want to plot the parabola \\(y=t^2\\) for \\(t\\) in the interval \\([-3,3]\\). In our language, this is the two-dimensional curve \\[\n\\g(t) = ( t, t^2 ) \\,, \\quad  t \\in [-3,3] \\,.\n\\] The two Python libraries we use to plot \\(\\g\\) are numpy and matplotlib. In short, numpy handles multi-dimensional arrays and matrices, and can perform high-level mathematical functions on them. For any question you may have about numpy, answers can be found in the searchable documentation available here. Instead matplotlib is a plotting library, with documentation here. Python libraries need to be imported every time you want to use them. In our case we will import:\nimport numpy as np\nimport matplotlib.pyplot as plt\nThe above imports numpy and the module pyplot from matplotlib, and renames them to np and plt, respectively. These shorthands are standard in the literature, and they make code much more readable.\nThe function for plotting 2D graphs is called plot(x,y) and is contained in plt. As the syntax suggests, plot takes as arguments two arrays \\[\nx=[x_1, \\ldots, x_n]\\,, \\quad  y=[y_1,\\ldots,y_n]\\,.\n\\] As output it produces a graph which is the linear interpolation of the points \\((x_i,y_i)\\) in \\(\\R^2\\), that is, consecutive points \\((x_i,y_i)\\) and \\((x_{i+1},y_{i+1})\\) are connected by a segment. Using plot, we can graph the curve \\(\\g(t)=(t,t^2)\\) like so:\n\n# Code for plotting gamma\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generating array t\nt = np.array([-3,-2,-1,0,1,2,3])\n\n# Computing array f\nf = t**2\n\n# Plotting the curve\nplt.plot(t,f)\n\n# Plotting dots\nplt.plot(t,f,\"ko\")\n\n# Showing the plot\nplt.show()\n\n\n\n\nLet us comment the above code. The variable t is a numpy array containing the ordered values \\[\nt = [-3,-2,-1,0,1,2,3]\\,.\n\\tag{2.1}\\] This array is then squared entry-by-entry via the operation \\(t\\ast\\!\\ast 2\\) and saved in the new numpy array f, that is, \\[\nf = [9,4,1,0,1,4,9] \\,.\n\\] The arrays t and f are then passed to plot(t,f), which produces the above linear interpolation, with t on the x-axis and f on the y-axis. The command plot(t,f,'ko') instead plots a black dot at each point \\((t_i,f_i)\\). The latter is clearly not needed to obtain a plot, and it was only included to highlight the fact that plot is actually producing a linear interpolation between points. Finally plt.show() displays the figure in the user window1.\nOf course one can refine the plot so that it resembles the continuous curve \\(\\g(t)=(t,t^2)\\) that we all have in mind. This is achieved by generating a numpy array t with a finer stepsize, invoking the function np.linspace(a,b,n). Such call will return a numpy array which contains n evenly spaced points, starts at a, and ends in b. For example np.linspace(-3,3,7) returns our original array t at 2.1, as shown below\n\n# Displaying output of np.linspace\n\nimport numpy as np\n\n# Generates array t by dividing interval \n# (-3,3) in 7 parts\nt = np.linspace(-3,3, 7)\n\n# Prints array t\nprint(\"t =\", t)\n\nt = [-3. -2. -1.  0.  1.  2.  3.]\n\n\nIn order to have a more refined plot of \\(\\g\\), we just need to increase \\(n\\).\n\n# Plotting gamma with finer step-size\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generates array t by dividing interval \n# (-3,3) in 100 parts\nt = np.linspace(-3,3, 100)\n\n# Computes f\nf = t**2\n\n# Plotting\nplt.plot(t,f)\nplt.show()\n\n\n\n\nWe now want to plot a parametric curve \\(\\g \\colon (a,b) \\to \\R^2\\) with \\[\n\\g(t) = (x(t), y(t)) \\,.\n\\] Clearly we need to modify the above code. The variable t will still be a numpy array produced by linspace. We then need to introduce the arrays x and y which ecode the first and second components of \\(\\g\\), respectively.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Divides time interval (a,b) in n parts\n# and saves output to numpy array t\nt = np.linspace(a, b, n)\n\n# Computes gamma from given functions x(y) and y(t)\nx = x(t)\ny = y(t)\n\n# Plots the curve\nplt.plot(x,y)\n\n# Shows the plot\nplt.show()\nWe use the above code to plot the 2D curve known as the Fermat’s spiral \\[\n\\g(t) = ( \\sqrt{t}  \\cos(t) , \\sqrt{t}  \\sin(t) ) \\quad\n\\text{ for } \\quad t \\in [0,50] \\,.\n\\tag{2.2}\\]\n# Plotting Fermat's spiral\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Divides time interval (0,50) in 500 parts\nt = np.linspace(0, 50, 500)\n\n# Computes Fermat's Spiral\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\n# Plots the Spiral\nplt.plot(x,y)\nplt.show()\nBefore displaying the output of the above code, a few comments are in order. The array t has size 500, due to the behavior of linspace. You can also fact check this information by printing np.size(t), which is the numpy function that returns the size of an array. We then use the numpy function np.sqrt to compute the square root of the array t. The outcome is still an array with the same size of t, that is, \\[\nt=[t_1,\\ldots,t_n]   \\quad \\implies \\quad \\sqrt{t} = [\\sqrt{t_1}, \\ldots, \\sqrt{t_n}] \\,.\n\\] Similary, the call np.cos(t) returns the array \\[\n\\cos(t) = [\\cos(t_1), \\ldots, \\cos(t_n)] \\,.\n\\] The two arrays np.sqrt(t) and np.cos(t) are then multiplied, term-by-term, and saved in the array x. The array y is computed similarly. The command plt.plot(x,y) then yields the graph of the Fermat’s spiral:\n\n\n\n\n\nFermat’s spiral\n\n\n\n\nThe above plots can be styled a bit. For example we can give a title to the plot, label the axes, plot the spiral by means of green dots, and add a plot legend, as coded below:\n\n# Adding some style\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Computing Spiral\nt = np.linspace(0, 50, 500)\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\n# Generating figure\nplt.figure(1, figsize = (4,4))\n\n# Plotting the Spiral with some options\nplt.plot(x, y, '--', color = 'deeppink', linewidth = 1.5, label = 'Spiral')\n\n# Adding grid\nplt.grid(True, color = 'lightgray')\n\n# Adding title\nplt.title(\"Fermat's spiral for t between 0 and 50\")\n\n# Adding axes labels\nplt.xlabel(\"x-axis\", fontsize = 15)\nplt.ylabel(\"y-axis\", fontsize = 15)\n\n# Showing plot legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\nAdding a bit of style\n\n\n\n\nLet us go over the novel part of the above code:\n\nplt.figure(): This command generates a figure object. If you are planning on plotting just one figure at a time, then this command is optional: a figure object is generated implicitly when calling plt.plot. Otherwise, if working with n figures, you need to generate a figure object with plt.figure(i) for each i between 1 and n. The number i uniquely identifies the i-th figure: whenever you call plt.figure(i), Python knows that the next commands will refer to the i-th figure. In our case we only have one figure, so we have used the identifier 1. The second argument figsize = (a,b) in plt.figure() specifies the size of figure 1 in inches. In this case we generated a figure 4 x 4 inches.\nplt.plot: This is plotting the arrays x and y, as usual. However we are adding a few aestethic touches: the curve is plotted in dashed style with --, in deep pink color and with a line width of 1.5. Finally this plot is labelled Spiral.\nplt.grid: This enables a grid in light gray color.\nplt.title: This gives a title to the figure, displayed on top.\nplt.xlabel and plt.ylabel: These assign labels to the axes, with font size 15 points.\nplt.legend(): This plots the legend, with all the labels assigned in the plt.plot call. In this case the only label is Spiral.\n\n\n\n\n\n\n\nMatplotlib styles\n\n\n\nThere are countless plot types and options you can specify in matplotlib, see for example the Matplotlib Gallery. Of course there is no need to remember every single command: a quick Google search can do wonders.\n\n\n\n\n\n\n\n\nGenerating arrays\n\n\n\nThere are several ways of generating evenly spaced arrays in Python. For example the function np.arange(a,b,s) returns an array with values within the half-open interval \\([a,b)\\), with spacing between values given by s. For example\n\nimport numpy as np\n\nt = np.arange(0,1, 0.2)\nprint(\"t =\",t)\n\nt = [0.  0.2 0.4 0.6 0.8]"
  },
  {
    "objectID": "sections/chap_2.html#implicit-curves-2d",
    "href": "sections/chap_2.html#implicit-curves-2d",
    "title": "2  Curves in Python",
    "section": "2.2 Implicit curves 2D",
    "text": "2.2 Implicit curves 2D\nA curve \\(\\g\\) in \\(\\R^2\\) can also be defined as the set of points \\((x,y) \\in \\R^2\\) satisfying \\[\nf(x,y)=0\n\\] for some given \\(f \\colon \\R^2 \\to \\R\\). For example let us plot the curve \\(\\g\\) implicitly defined by \\[\nf(x,y) =( 3 x^2 - y^2 )^2 \\ y^2  -  (x^2 + y^2 )^4\n\\] for \\(-1 \\leq x,y \\leq 1\\). First, we need a way to generate a grid in \\(\\R^2\\) so that we can evaluate \\(f\\) on such grid. To illustrate how to do this, let us generate a grid of spacing 1 in the 2D square \\([0,4]^2\\). The goal is to obtain the 5 x 5 matrix of coordinates \\[\nA = \\left(\n\\begin{matrix}\n(0,0) &  (1,0)  &  (2,0) & (3,0) & (4,0) \\\\\n(0,1) &  (1,1)  &  (2,1) & (3,1) & (4,1) \\\\\n(0,2) &  (1,2)  &  (2,2) & (2,3) & (2,4) \\\\\n(0,3) &  (1,3)  &  (2,3) & (3,3) & (3,4) \\\\\n(0,4) &  (1,4)  &  (2,4) & (3,4) & (4,4) \\\\\n\\end{matrix}\n\\right)    \n\\] which corresponds to the grid of points\n\n\n\n\n\nFigure 2.1: The 5 x 5 grid corresponding to the matrix A\n\n\n\n\nTo achieve this, first generate x and y coordinates using\nx = np.linspace(0, 4, 5)\ny = np.linspace(0, 4, 5)\nThis generates coordinates \\[\nx = [0, 1, 2, 3, 4] \\,, \\quad  y = [0, 1, 2, 3, 4] \\,.\n\\] We then need to obtain two matrices \\(X\\) and \\(Y\\): one for the \\(x\\) coordinates in \\(A\\), and one for the \\(y\\) coordinates in \\(A\\). This can be achieved with the code\nX[0,0] = 0 \nX[0,1] = 1\nX[0,2] = 2\nX[0,3] = 3\nX[0,4] = 4\nX[1,0] = 0\nX[1,1] = 1\n...\nx[4,3] = 3\nx[4,4] = 4\nand similarly for \\(Y\\). The output would be the two matrices \\(X\\) and \\(Y\\) \\[\nX = \\left(\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n\\end{matrix}\n\\right)   \\,, \\quad\nY =\n\\left(\n\\begin{matrix}\n0 &  0 &  0 & 0 & 0 \\\\\n1 &  1 &  1 & 1 & 1 \\\\\n2 &  2 &  2 & 2 & 2 \\\\\n3 &  3 &  3 & 3 & 3 \\\\\n4 &  4 &  4 & 4 & 4 \\\\\n\\end{matrix}\n\\right)   \n\\]\nIf now we plot \\(X\\) against \\(Y\\) via the command\nplt.plot(X, Y, 'k.')\nwe obtain Figure 2.1. In the above command the style 'k.' represents black dots. This procedure would be impossible with large vectors. Thankfully there is a function in numpy doing exactly what we need: np.meshgrid.\n\n# Demonstrating np.meshgrid\n\nimport numpy as np\n\n# Generating x and y coordinates\nxlist = np.linspace(0, 4, 5)\nylist = np.linspace(0, 4, 5)\n\n# Generating grid X, Y\nX, Y = np.meshgrid(xlist, ylist)\n\n# Printing the matrices X and Y\n# np.array2string is only needed to align outputs\nprint('X =', np.array2string(X, prefix='X= '))\nprint('\\n')  \nprint('Y =', np.array2string(Y, prefix='Y= '))\n\nX = [[0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]\n    [0. 1. 2. 3. 4.]]\n\n\nY = [[0. 0. 0. 0. 0.]\n    [1. 1. 1. 1. 1.]\n    [2. 2. 2. 2. 2.]\n    [3. 3. 3. 3. 3.]\n    [4. 4. 4. 4. 4.]]\n\n\nNow that we have our grid, we can evaluate the function \\(f\\) on it. This is simply done with the command\nZ =((3*(X**2) - Y**2)**2)*(Y**2) - (X**2 + Y**2)**4 \nThis will return the matrix \\(Z\\) containing the values \\(f(x_i,y_i)\\) for all \\((x_i,y_i)\\) in the grid \\([X,Y]\\). We are now interested in plotting the points in the grid \\([X,Y]\\) for which \\(Z\\) is zero. This is achieved with the command\nplt.contour(X, Y, Z, [0])\nPutting the above observations together, we have the code for plotting the curve \\(f=0\\) for \\(-1 \\leq x,y \\leq 1\\).\n\n# Plotting f=0\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generates coordinates and grid\nxlist = np.linspace(-1, 1, 5000)\nylist = np.linspace(-1, 1, 5000)\nX, Y = np.meshgrid(xlist, ylist)\n\n# Computes f\nZ =((3*(X**2) - Y**2)**2)*(Y**2) - (X**2 + Y**2)**4 \n\n# Creates figure object\nplt.figure(figsize = (4,4))\n\n# Plots level set Z = 0\nplt.contour(X, Y, Z, [0])\n\n# Set axes labels\nplt.xlabel(\"x-axis\", fontsize = 15)\nplt.ylabel(\"y-axis\", fontsize = 15)\n\n# Shows plot\nplt.show()\n\n\n\n\nPlot of the curve defined by f=0"
  },
  {
    "objectID": "sections/chap_2.html#curves-in-3d",
    "href": "sections/chap_2.html#curves-in-3d",
    "title": "2  Curves in Python",
    "section": "2.3 Curves in 3D",
    "text": "2.3 Curves in 3D\nPlotting in 3D with matplotlib requires the mplot3d toolkit, see here for documentation. Therefore our first lines will always be\n# Packages for 3D plots\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\nWe can now generate empty 3D axes\n\n# Generates and plots empty 3D axes\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Creates figure object\nfig = plt.figure(figsize = (4,4))\n\n# Creates 3D axes object\nax = plt.axes(projection = '3d')\n\n# Shows the plot\nplt.show()\n\n\n\n\nIn the above code fig is a figure object, while ax is an axes object. In practice, the figure object contains the axes objects, and the actual plot information will be contained in axes. If you want multiple plots in the figure container, you should use the command\nax = fig.add_subplot(nrows = m, ncols = n, pos = k)\nThis generates an axes object ax in position k with respect to a m x n grid of plots in the container figure. For example we can create a 3 x 2 grid of empty 3D axes as follows\n\n# Generates 3 x 2 empty 3D axes\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Creates container figure object\nfig = plt.figure(figsize = (6,8))\n\n# Creates 6 empty 3D axes objects\nax1 = fig.add_subplot(3, 2, 1, projection = '3d')\nax2 = fig.add_subplot(3, 2, 2, projection = '3d')\nax3 = fig.add_subplot(3, 2, 3, projection = '3d')\nax4 = fig.add_subplot(3, 2, 4, projection = '3d')\nax5 = fig.add_subplot(3, 2, 5, projection = '3d')\nax6 = fig.add_subplot(3, 2, 6, projection = '3d')\n\n# Shows the plot\nplt.show()\n\n\n\n\nWe are now ready to plot a 3D parametric curve \\(\\g \\colon (a,b) \\to \\R^3\\) of the form \\[\n\\g(t) = (x(t), y(t), z(t))\n\\] with the code\n# Code to plot 3D curve\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure and 3D axes\nfig = plt.figure(figsize = (size1,size2))\nax = plt.axes(projection = '3d')\n\n# Plots grid\nax.grid(True)\n\n# Divides time interval (a,b)\n# into n parts and saves them in array t\nt = np.linspace(a, b, n)\n\n# Computes the curve gamma on array t\n# for given functions x(t), y(t), z(t)\nx = x(t) \ny = y(t)\nz = z(t)\n\n# Plots gamma\nax.plot3D(x, y, z)\n\n# Setting title for plot\nax.set_title('3D Plot of gamma')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad = 'p')\nax.set_ylabel('y', labelpad = 'p')\nax.set_zlabel('z', labelpad = 'p')\n\n# Shows the plot\nplt.show()\nFor example we can use the above code to plot the Helix \\[\nx(t) = \\cos(t) \\,, \\quad\ny(t) = \\sin(t) \\,, \\quad\nz(t) = t\n\\tag{2.3}\\] for \\(t \\in [0,6\\pi]\\).\n\n# Plotting 3D Helix\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure and 3D axes\nfig = plt.figure(figsize = (4,4))\nax = plt.axes(projection = '3d')\n\n# Plots grid\nax.grid(True)\n\n# Divides time interval (0,6pi) in 100 parts \nt = np.linspace(0, 6*np.pi, 100)\n\n# Computes Helix\nx = np.cos(t) \ny = np.sin(t)\nz = t\n\n# Plots Helix - We added some styling\nax.plot3D(x, y, z, color = \"deeppink\", linewidth = 2)\n\n# Setting title for plot\nax.set_title('3D Plot of Helix')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad = 20)\nax.set_ylabel('y', labelpad = 20)\nax.set_zlabel('z', labelpad = 20)\n\n# Shows the plot\nplt.show()\n\n\n\n\nWe can also change the viewing angle for a 3D plot store in ax. This is done via\nax.view_init(elev = e, azim = a)\nwhich displays the 3D axes with an elevation angle elev of e degrees and an azimuthal angle azim of a degrees. In other words, the 3D plot will be rotated by e degrees above the xy-plane and by a degrees around the z-axis. For example, let us plot the helix with 2 viewing angles. Note that we generate 2 sets of axes with the add_subplot command discussed above.\n\n# Plotting 3D Helix\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object\nfig = plt.figure(figsize = (4,4))\n\n# Generates 2 sets of 3D axes\nax1 = fig.add_subplot(1, 2, 1, projection = '3d')\nax2 = fig.add_subplot(1, 2, 2, projection = '3d')\n\n# We will not show a grid this time\nax1.grid(False)\nax2.grid(False)\n\n# Divides time interval (0,6pi) in 100 parts \nt = np.linspace(0, 6*np.pi, 100)\n\n# Computes Helix\nx = np.cos(t) \ny = np.sin(t)\nz = t\n\n# Plots Helix on both axes\nax1.plot3D(x, y, z, color = \"deeppink\", linewidth = 1.5)\nax2.plot3D(x, y, z, color = \"deeppink\", linewidth = 1.5)\n\n# Setting title for plots\nax1.set_title('Helix from above')\nax2.set_title('Helix from side')\n\n# Changing viewing angle of ax1\n# View from above has elev = 90 and azim = 0\nax1.view_init(elev = 90, azim = 0)\n\n# Changing viewing angle of ax2\n# View from side has elev = 0 and azim = 0\nax2.view_init(elev = 0, azim = 0)\n\n# Shows the plot\nplt.show()"
  },
  {
    "objectID": "sections/chap_2.html#sec-plot-2d-interactive",
    "href": "sections/chap_2.html#sec-plot-2d-interactive",
    "title": "2  Curves in Python",
    "section": "2.4 Interactive plots",
    "text": "2.4 Interactive plots\nMatplotlib produces beautiful static plots; however it lacks built in interactivity. For this reason I would also like to show you how to plot curves with Plotly, a very popular Python graphic library which has built in interactivity. Documentation for Plotly and lots of examples can be found here.\n\n2.4.1 2D Plots\nSay we want to plot the 2D curve \\(\\g \\colon (a,b) \\to \\R^2\\) parametrized by \\[\n\\g(t) = ( x(t) , y(t) ) \\,.\n\\] The Plotly module needed is called graph_objects, usually imported as go. The function for line plots is called Scatter. For documentation and examples see link. The code for plotting \\(\\g\\) is as follows.\n# Plotting gamma 2D\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Compute times grid by dividing (a,b) in \n# n equal parts\nt = np.linspace(a, b, n)\n\n# Compute the parametric curve gamma\n# for given functions x(t) and y(t)\nx = x(t)\ny = y(t)\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\ndata = go.Scatter(x = x, y = y, mode = 'lines', name = 'gamma')\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Display the figure\nfig.show()\nSome comments about the functions called above:\n\ngo.Figure: generates an empty Plotly figure\ngo.Scatter: generates the actual plot. By default a scatter plot is produced. To obtain linear interpolation of the points, set mode = 'lines'. You can also label the plot with name = \"string\"\nadd_trace: adds a plot to a figure\nshow: displays a figure\n\nAs an example, let us plot the Fermat’s Spiral defined at 2.2. Compared to the above code, we also add a bit of styling.\n\n# Plotting Fermat's Spiral\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Compute times grid by dividing (0,50) in \n# 500 equal parts\nt = np.linspace(0, 50, 500)\n\n# Computes Fermat's Spiral\nx = np.sqrt(t) * np.cos(t)\ny = np.sqrt(t) * np.sin(t)\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\ndata = go.Scatter(x = x, y = y, mode = 'lines', name = 'gamma')\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Here we start with the styling options\n# First we set a figure title\nfig.update_layout(title_text = \"Plotting Fermat's Spiral with Plotly\")\n\n# Adjust figure size\nfig.update_layout(autosize = False, width = 600, height = 600)\n\n# Change background canvas color\nfig.update_layout(paper_bgcolor = \"snow\")\n\n# Axes styling: adding title and ticks positions \nfig.update_layout(\nxaxis=dict(\n        title_text=\"X-axis Title\",\n        titlefont=dict(size=20),\n        tickvals=[-6,-4,-2,0,2,4,6],\n        ), \n\nyaxis=dict(\n        title_text=\"Y-axis Title\",\n        titlefont=dict(size=20),\n        tickvals=[-6,-4,-2,0,2,4,6],\n        )\n)\n\n# Display the figure\nfig.show()\n\n\n                                                \n\n\nAs you can examine by moving the mouse pointer, the above plot is interactive. Note that the style customizations could be listed in a single call of the function update_layout. There are also pretty buit-in themes available, see here. The layout can be specified with the command\nfig.update_layout(template = template_name)\nwhere template_name can be \"plotly\", \"plotly_white\", \"plotly_dark\", \"ggplot2\", \"seaborn\", \"simple_white“.\n\n\n2.4.2 3D Plots\nWe now want to plot a 3D curve \\(\\g \\colon (a,b) \\to \\R^3\\) parametrized by \\[\n\\g(t) = ( x(t) , y(t) , z(t)) \\,.\n\\] Again we use the Plotly module graph_objects, imported as go. The function for 3D line plots is called Scatter3d, and documentation and examples can be found at link. The code for plotting \\(\\g\\) is as follows.\n# Plotting gamma 3D\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Compute times grid by dividing (a,b) in \n# n equal parts\nt = np.linspace(a, b, n)\n\n# Compute the parametric curve gamma\n# for given functions x(t), y(t), z(t)\nx = x(t)\ny = y(t)\nz = z(t)\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\ndata = go.Scatter3d(x = x, y = y, z = z, mode = 'lines', name = 'gamma')\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Display the figure\nfig.show()\nThe functions go.Figure, add_trace and show appearing above are described in the previous Section. The new addition is go.Scatter3d, which generates a 3D scatter plot of the points stored in the array [x,y,z]. Setting mode = 'lines' results in a linear interpolation of such points. As before, the curve can be labeled by setting name = \"string\".\nAs an example, we plot the 3D Helix defined at 2.3. We also add some styling. We can also use the same pre-defined templates descirbed for go.Scatter in the previous section, see here for official documentation.\n\n# Plotting 3D Helix\n\n# Import libraries\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Divides time interval (0,6pi) in 100 parts \nt = np.linspace(0, 6*np.pi, 100)\n\n# Computes Helix\nx = np.cos(t) \ny = np.sin(t)\nz = t\n\n# Create empty figure object and saves \n# it in the variable \"fig\"\nfig = go.Figure()\n\n# Create the line plot object\n# We add options for the line width and color\ndata = go.Scatter3d(\n    x = x, y = y, z = z, \n    mode = 'lines', name = 'gamma', \n    line = dict(width = 10, color = \"darkblue\")\n    )\n\n# Add \"data\" plot to the figure \"fig\"\nfig.add_trace(data)\n\n# Here we start with the styling options\n# First we set a figure title\nfig.update_layout(title_text = \"Plotting 3D Helix with Plotly\")\n\n# Adjust figure size\nfig.update_layout(\n    autosize = False, \n    width = 600, \n    height = 600\n    )\n\n# Set pre-defined template\nfig.update_layout(template = \"seaborn\")\n\n# Options for curve line style\n\n\n# Display the figure\nfig.show()\n\n\n                                                \n\n\nThe above plot is interactive: you can pan arond by dragging the pointer. Once again, the style customizations could be listed in a single call of the function update_layout."
  },
  {
    "objectID": "sections/chap_2.html#footnotes",
    "href": "sections/chap_2.html#footnotes",
    "title": "2  Curves in Python",
    "section": "",
    "text": "The command plt.show() can be omitted if working in Jupyter Notebook, as it is called by default.↩︎"
  },
  {
    "objectID": "sections/chap_3.html#tangent-vectors",
    "href": "sections/chap_3.html#tangent-vectors",
    "title": "3  Parametrized curves",
    "section": "3.1 Tangent vectors",
    "text": "3.1 Tangent vectors\nLooking at Figure 3.2, it seems like the vector \\[\n\\dot \\g(\\pi/2) = (-1,0)\n\\] is tangent to the circle at the point \\[\n\\g(\\pi/2) = (0,1) \\,.\n\\] Is this a coincidence? Not that all. Let us look at the definition of derivative at a point: \\[\n\\dot \\g (t) := \\lim_{\\delta \\to 0} \\frac{\\g(t + \\delta) - \\g(t)}{\\delta} \\,.\n\\] If we just look at the quantity \\[\n\\frac{\\g(t + \\delta) - \\g(t)}{\\delta}\n\\] for non-negative \\(\\delta\\), we see that this vector is parallel to the chord joining \\(\\g(t)\\) to \\(\\g(t + \\delta)\\), as shown in Figure 3.3 below. As \\(\\delta \\to 0\\), the length of the chord tends to zero. However the direction of the chord becomes parallel to that of the tangent vector of the curve \\(\\g\\) at \\(\\g(t)\\). Since \\[\n\\frac{\\g(t + \\delta) - \\g(t)}{\\delta}  \\to \\dot \\g(t)\n\\] as \\(\\delta \\to 0\\), we see that \\(\\dot \\g (t)\\) is parallel to the tangent of \\(\\g\\) at \\(\\g(t)\\), as showin in Figure 3.3.\n\n\n\nFigure 3.3: Approximating the tangent vector\n\n\nThe above remark motivates the following definition.\n\nDefinition 6: Tangent vectorLet \\(\\g \\ \\colon (a,b) \\to \\R^n\\) be a parametrized curve. The tangent vector to \\(\\g\\) at the point \\(\\g(t)\\) is defined as \\[\n\\tau:= \\dot \\g(t) \\,.\n\\]\n\n\n\nExample 7: Tangent vector to helixThe helix is described by the parametric curve \\[\n\\g \\ \\colon \\R \\to \\R^3\n\\] with \\[\n\\g_1(t) = \\cos (t)\\, ,  \\,\\,\n\\g_2(t) = \\sin (t)\\, ,  \\,\\,\n\\g_3(t) = t .\n\\] This is plotted in Figure 3.4 below. The tangent vector at point \\(\\g(t)\\) is given by \\[\n\\dot \\g (t) = ( -\\sin(t), \\cos(t) , 1) \\,.\n\\] For example in Figure 3.4 we plot the tangent vector at time \\(t = \\pi/2\\), that is, \\[\n\\dot\\g(\\pi/2) = (-1,0,\\pi/2) \\,.\n\\] The above looks very similar to the tangent vector to the circle. Except that there is a \\(z\\) component, and that component is constant and equal to \\(1\\). Intuitively this means that the helix is lifting from the plane \\(xy\\) with constant speed with respect to the \\(z\\)-axis. We will soon give a name to this concept.\n\n\n\n\n\n\n\nFigure 3.4: Plot of Helix with tangent vector\n\n\n\n\n\nRemark 8: Avoiding potential ambiguitiesSometimes it will happen that a curve self intersects, meaning that there are two time instants \\(t_1\\) and \\(t_2\\) and a point \\(p \\in \\R^n\\) such that \\[\np = \\g(t_1) = \\g(t_2)\\,.\n\\] In this case there is ambiguity in talking about the tangent vector at the point \\(p\\): in principle there are two tangent vectors \\(\\dot\\g(t_1)\\) and \\(\\dot\\g(t_2)\\), and it could happen that \\[\n\\dot\\g(t_1) \\neq  \\dot\\g(t_1)\\,.\n\\] Thus the concept of tangent at \\(p\\) is not well-defined. We need then to be more precise and talk about tangent at a certain time-step \\(t\\), rather than at some point \\(p\\). We however do not amend Definition 6, but you should keep this potential ambiguity in mind.\n\n\n\nExample 9: The Lemniscate, a self intersecting curveFor example consider \\(\\g \\ \\colon [0,2\\pi] \\to \\R^2\\) defined as \\[\n\\g_1(t) = \\sin (t)\\, ,  \\,\\,\n\\g_2(t) = \\sin (t) \\cos(t) \\, .\n\\] Such curve is called Lemniscate, see Wikipedia page, and is plotted in Figure 3.5 below. The orgin \\((0,0)\\) is a point of self-intersection, meaning that \\[\n\\g (0) = \\g (\\pi) = (0,0) \\,.\n\\] The tangent vector at point \\(\\g(t)\\) is given by \\[\n\\dot \\g(t) = (\\cos(t), \\cos^2(t) - \\sin^2(t) )\n\\] and therefore we have two tangents at \\((0,0)\\), that is, \\[\n\\tau_1 = \\dot\\g(0) = (1,1) \\,, \\,\\,\n\\tau_2 = \\dot\\g(\\pi) = (-1,1) \\,.\n\\]\n\n\n\n\n\n\n\nFigure 3.5: The Lemniscate curve"
  },
  {
    "objectID": "sections/chap_3.html#length-of-curves",
    "href": "sections/chap_3.html#length-of-curves",
    "title": "3  Parametrized curves",
    "section": "3.2 Length of curves",
    "text": "3.2 Length of curves\nFor a vector \\(v \\in \\R^n\\) with components \\[\nv=(v_1,\\ldots,v_n),\n\\] its length is defined by \\[\n\\norm{v}:= \\sqrt{\\sum_{i=1}^n v_i^2 } \\,.\n\\] The above is just an extension of the Pythagoras theorem to \\(\\R^n\\), and the length of \\(v\\) is computed from the origin.\n\n\n\nInterpretation of \\(\\norm{v}\\) in \\(\\R^2\\)\n\n\nIf we have a second vector \\(u \\in \\R^n\\), then the quantity \\[\n\\norm{u-v}:= \\sqrt{\\sum_{i=1}^n (u_i-v_i)^2 }\n\\] measures the length of the difference between \\(u\\) and \\(v\\).\n\n\n\nInterpretation of \\(\\norm{u-v}\\) in \\(\\R^2\\)\n\n\nWe would like to define the concept of length of a curve. Intuitively, one could proceed by approximation as in the figure below.\n\n\n\nApproximating the length of \\(\\g\\)\n\n\nIn formulae, this means choosing some time instants \\[\nt_0, \\ldots, t_m \\in (a,b) \\,.\n\\] The length of the segment connecting \\(\\g(t_{i-1})\\) to \\(\\g(t_i)\\) is given by \\[\n\\norm{ \\g(t_i) - \\g(t_{i-1}) } \\,.\n\\] Thus \\[\nL(\\g) \\approx \\sum_{i=1}^m \\norm{ \\g(t_i) - \\g(t_{i-1}) } \\,.  \n\\tag{3.1}\\] Intuitively, if we increase the number of points \\(t_i\\), the quantity on the RHS of (3.1) should approximate \\(L(\\g)\\) better and better. Let us make this precise.\n\nDefinition 10: PartitionLet \\((a,b)\\) be an interval. A partition \\(\\mathcal{P}\\) of \\([a,b]\\) is a vector of time instants \\[\n\\mathcal{P} = (t_0,\\ldots, t_k) \\in [a,b]^{m+1}\n\\] with \\[\nt_0 = a &lt; t_1 &lt; \\ldots &lt; t_{m-1} &lt; t_m = b \\,.\n\\] If \\(\\mathcal{P}\\) is a partition of \\([a,b]\\), we define its maximum length as \\[\n\\norm{\\mathcal{P}} := \\max_{1 \\leq i \\leq m} |t_{i} - t_{i-1}| \\,.\n\\]\n\n\nNote that \\(\\norm{\\mathcal{P}}\\) measures how fine the partition \\(\\mathcal{P}\\) is.\n\nDefinition 11: Length of approximating polygonal curveSuppose \\(\\g \\colon (a,b) \\to \\R^n\\) is a parametrized curve and \\(\\mathcal{P}\\) a partition of \\([a,b]\\). We define the length of the polygonal curve connecting the points \\[\n\\g(t_0)\\,, \\,\\, \\g(t_1) \\,,  \\,\\, \\ldots, \\,\\, \\g(t_m)\n\\] as \\[\nL(\\g, \\mathcal{P}) := \\sum_{i=1}^m \\norm{ \\g(t_i) - \\g(t_{i-1}) } \\,.\n\\]\n\n\nIf \\(\\norm{\\mathcal{P}}\\) becomes smaller and smaller, that is, the partition \\(\\mathcal{P}\\) is finer and finer, it is reasonable to say that \\[\nL(\\g, \\mathcal{P})\n\\] is approximating the length of \\(\\g\\). We take this as definition of length.\n\nDefinition 12: Rectifiable curve and lengthSuppose \\(\\g \\colon (a,b) \\to \\R^n\\) is a parametrized curve. We say that \\(\\g\\) is rectifiable if the limit \\[\nL(\\g) = \\lim_{ \\norm{P} \\to 0}   \\ L(\\g,\\mathcal{P})\n\\] exists finite. In such case we call \\(L(\\g)\\) the length of \\(\\g\\).\n\n\nThis definition definitely corresponds to our geometrical intuition of length of a curve.\n\nQuestion 13How do we use such definition in practice to compute the length of a given curve \\(\\g\\)?\n\n\nThankfully, when \\(\\g\\) is smooth, the length \\(L(\\g)\\) can be characterized in terms of \\(\\dot\\g\\). Indeed, when \\(\\delta\\) is small, then the quantity \\[\n\\norm{\\g(t + \\delta) - \\g(t)}\n\\] is approximating the length of \\(\\g\\) between \\(\\g(t)\\) and \\(\\g(t + \\delta)\\). Multiplying and dividing by \\(\\delta\\) we obtain \\[\n\\frac{\\norm{\\g(t + \\delta) - \\g(t)}}{\\delta} \\, \\delta\n\\] which for small \\(\\delta\\) is close to \\[\n\\norm{\\dot\\g(t)} \\,\\delta \\,.\n\\] We can now divide the time interval \\((a,b)\\) in steps \\(t_0, \\ldots, t_m\\) with \\(|t_{i}-t_{i-1}| &lt; \\delta\\) and obtain \\[\\begin{align}\n\\norm{\\g(t_{i}) - \\g(t_{i-1}) } & = \\frac{\\norm{\\g(t_{i}) - \\g(t_{i-1})}}{ |t_{i}-t_{i-1}| } |t_{i}-t_{i-1}| \\\\\n& \\approx \\norm{ \\dot\\g(t_i)} \\delta\n\\end{align}\\] since \\(\\delta\\) is small. Therefore \\[\nL(\\g) \\approx \\sum_{i=1}^m  \\norm{\\g(t_{i}) - \\g(t_{i-1})}\n\\approx \\sum_{i=1}^m   \\norm{\\dot\\g(t_i)} \\,\\delta \\,.\n\\] The RHS is a Riemann sum, therefore \\[\n  L(\\g) \\approx \\int_a^b  \\norm{\\dot\\g(t)} \\, dt \\,.\n\\]\nThe above argument can be made rigorous, as we see in the next theorem.\n\n\n\nApproximating \\(L(\\g)\\) via \\(\\dot\\g\\)\n\n\n\nTheorem 14: Characterizing the length of \\(\\g\\)Assume \\(\\g \\ \\colon [a,b] \\to \\R^n\\) is a parametrized curve, with \\([a,b]\\) bounded. Then \\(\\g\\) is rectifiable and \\[\nL(\\g) = \\int_a^b  \\norm{\\dot\\g(t)} \\, dt \\,.\n\\tag{3.2}\\]\n\n\n\nProofStep 1. The integral in (3.2) is bounded.\nSince \\(\\g\\) is smooth, in particular \\(\\dot \\g\\) is continuous. Since \\([a,b]\\) is bounded, then \\(\\dot \\g\\) is bounded, that is \\[\n\\sup_{t \\in [a,b]} \\norm{\\dot \\g(t)} \\leq C\n\\] for some constant \\(C \\geq 0\\). Therefore \\[\n\\int_a^b  \\norm{\\dot\\g(t)} \\, dt \\leq C (b-a) &lt; \\infty \\,.\n\\]\nStep 2. Writing (3.2) as limit.\nRecalling that \\[\nL(\\g) = \\lim_{\\norm{\\mathcal{P}} \\to 0} \\ L(\\g,\\mathcal{P}) \\,,\n\\] whenever the limit is finite, in order to show (3.2) we then need to prove \\[\nL(\\g,\\mathcal{P}) \\to \\int_a^b  \\norm{\\dot\\g(t)} \\, dt\n\\] as \\(\\norm{\\mathcal{P}} \\to 0\\). Showing the above means proving that: for every \\(\\e &gt; 0\\) there exists a \\(\\delta &gt; 0\\) such that, if \\(\\mathcal{P}\\) is a partition of \\([a,b]\\) such that \\(\\norm{ \\mathcal{P} }&lt;\\delta\\), then \\[\n\\left|    \\int_a^b  \\norm{\\dot\\g(t)} \\, dt -  L(\\g , \\mathcal{P} )        \\right| &lt; \\e \\,.\n\\tag{3.3}\\]\nStep 3. First estimate in (3.3).\nThis first estimate is easy, and only relies on the Fundamental Theorem of Calculus. To be more precise, we will show that each polygonal has shorter length than \\(\\int_{a}^b \\norm{ \\dot\\g (t)} \\, dt\\). To this end, take an arbitrary partition \\(\\mathcal{P} = (t_0, \\ldots, t_m)\\) of \\([a,b]\\). Then for each \\(i = 1,\\ldots,m\\) we have \\[\n\\norm{  \\g(t_i) - \\g (t_{i-1}) } = \\norm{  \\int_{t_{i-1}}^{t_i}  \\dot\\g (t)\\, dt } \\leq   \\int_{t_{i-1}}^{t_i}\\norm{   \\dot\\g (t)} \\, dt   \n\\] where we used the Fundamental Theorem of calculus, and usual integral properties. Therefore by definition \\[\\begin{align}\nL(\\g,\\mathcal{P} ) & = \\sum_{i=1}^m  \\norm{  \\g(t_i) - \\g (t_{i-1}) } \\\\\n& \\leq \\sum_{i=1}^m  \\int_{t_{i-1}}^{t_i} \\norm{   \\dot\\g (t)} \\, dt \\\\\n& = \\int_{a}^b \\norm{   \\dot\\g (t)} \\, dt \\,.\n\\end{align}\\] We have then shown \\[\nL(\\g, \\mathcal{P}) \\leq \\int_{a}^b \\norm{   \\dot\\g (t)} \\, dt\n\\tag{3.4}\\] for all partitions \\(\\mathcal{P}\\).\nStep 4. Second estimate in (3.3).\nThe second estimate is more delicate. We need to carefully construct a polygonal so that its length is close to \\(\\int_a^b \\norm{ \\dot \\g} \\,dt\\). This will be possible by uniform continuity of \\(\\dot\\g\\). Indeed, note that \\(\\dot \\g\\) is continuous on the compact set \\([a,b]\\). Therefore it is uniformly continuous by the Heine-Borel Theorem. Fix \\(\\e&gt;0\\). By uniform continuity of \\(\\dot \\g\\) there exists \\(\\delta &gt;0\\) such that \\[\n|t-s| &lt; \\delta \\implies \\norm{ \\dot\\g(t)-\\dot\\g(s) } &lt; \\frac{ \\e }{b-a} \\,.\n\\tag{3.5}\\] for all \\(t,s \\in [a,b]\\). Let \\(\\mathcal{P} = (t_0, \\ldots, t_m)\\) be a partition of \\([a,b]\\) with \\(\\norm{\\mathcal{P}} &lt; \\delta\\). Recall that \\[\n\\norm{\\mathcal{P}} = \\max_{i=1,\\ldots ,m} |t_i - t_{i-1}| \\,.\n\\] Therefore the condition \\(\\norm{\\mathcal{P}} &lt; \\delta\\) implies \\[\n|t_i - t_{i-1}| &lt; \\delta\n\\tag{3.6}\\] for each \\(i = 1, \\ldots, m\\). For all \\(i = 1, \\ldots, m\\) and \\(s \\in [t_{i-1},t_i]\\) we have \\[\\begin{align}\n\\g(t_i) - \\g(t_{i-1}) & = \\int_{t_{i-1}}^{ t_i }  \\dot\\g(t)\\, dt \\\\\n                      & =  \\int_{t_{i-1}}^{ t_i } \\dot\\g(s) +  (\\dot\\g(t) - \\dot\\g(s))    \\, dt \\\\\n                      & = ( t_i - t_{i-1} ) \\dot\\g(s) + \\int_{t_{i-1}}^{ t_i }   (\\dot\\g(t) - \\dot\\g(s))    \\, dt\n\\end{align}\\] Therefore \\[\n\\norm{ \\g(t_i) - \\g(t_{i-1}) }  = \\norm{ ( t_i - t_{i-1} ) \\dot\\g(s) +\n\\int_{t_{i-1}}^{ t_i }   (\\dot\\g(t) - \\dot\\g(s))    \\, dt }\n\\tag{3.7}\\] We can now use the reverse triangle inequality \\[\n| \\| x\\| - \\norm{y}| \\leq \\norm{x-y}\\,,\n\\] for all \\(x,y \\in \\R^n\\), which implies \\[\n\\norm{x+y}  = \\norm{x - (-y)} \\geq \\| x \\| - \\norm{y}\n\\] for all \\(x,y \\in \\R^n\\). Applying the above to (3.7) we get \\[\n\\norm{ \\g(t_i) - \\g(t_{i-1}) }  \\geq\n( t_i - t_{i-1} ) \\norm{\\dot\\g(s)} -\n\\norm{ \\int_{t_{i-1}}^{ t_i }   (\\dot\\g(t) - \\dot\\g(s))    \\, dt }\n\\tag{3.8}\\] By standard properties of integral we also have \\[\n\\norm{ \\int_{t_{i-1}}^{ t_i }   (\\dot\\g(t) - \\dot\\g(s))    \\, dt }\n\\leq\n\\int_{t_{i-1}}^{ t_i }   \\norm{\\dot\\g(t) - \\dot\\g(s)}    \\, dt\\,,\n\\] so that (3.8) implies \\[\n\\norm{ \\g(t_i) - \\g(t_{i-1}) } \\geq ( t_i - t_{i-1} ) \\norm{\\dot\\g(s)}   - \\int_{t_{i-1}}^{ t_i }   \\norm{\\dot\\g(t) - \\dot\\g(s)}    \\, dt\\,.\n\\tag{3.9}\\] Since \\(t,s \\in [t_{i-1},t_i]\\), then \\[\n|t-s| \\leq | t_{i} - t_{i-1} |   &lt;  \\delta\n\\] where the last inequality follows by (3.6). Thus by uniform continuity (3.5) we get \\[\n\\norm{ \\dot\\g(t) - \\dot\\g(s) } &lt; \\frac{\\e}{b-a} \\,.\n\\] We can therefore further estimate (3.9) and obtain \\[\\begin{align}\n\\norm{ \\g(t_i) - \\g(t_{i-1}) } & \\geq ( t_i - t_{i-1} ) \\norm{\\dot\\g(s)}   - \\int_{t_{i-1}}^{ t_i }   \\norm{\\dot\\g(t) - \\dot\\g(s)}    \\, dt \\\\\n& \\geq  ( t_i - t_{i-1} ) \\norm{\\dot\\g(s)} -  ( t_i - t_{i-1} ) \\frac{\\e}{b-a}    \\, dt \\,.\n\\end{align}\\] Dividing the above by \\(t_i - t_{i-1}\\) we get \\[\n\\frac{ \\norm{ \\g(t_i) - \\g(t_{i-1}) } }{ t_i - t_{i-1}  } \\geq\n\\norm{\\dot\\g(s)} - \\frac{\\e}{b-a}  \\,.\n\\] Integrating the above over \\(s\\) in the interval \\([t_{i-1}, t_i ]\\) we get \\[\n\\norm{ \\g(t_i) - \\g(t_{i-1}) }  \\geq \\int_{t_{i-1}}^{ t_i } \\norm{\\dot\\g(s)} \\, ds  - \\frac{\\e}{b-a} (t_i - t_{i-1}) \\,.\n\\] Summing over \\(i=1,\\ldots,m\\) we get \\[\nL(\\mathcal{P},\\g) \\geq \\int_{a}^b \\norm{\\dot\\g(s)} \\, ds - \\e\n\\tag{3.10}\\] since \\[\n\\sum_{i=1}^m (t_i - t_{i-1}) = t_m - t_0 = b - a \\,.\n\\]\nConclusion.\nPutting together (3.4) and (3.10) we get \\[\n\\int_{a}^b \\norm{\\dot\\g(s)} \\, ds - \\e   \\leq L(\\mathcal{P},\\g)\n\\leq  \\int_{a}^b \\norm{\\dot\\g(s)} \\, ds\n\\] which implies (3.3), concluding the proof.\n\n\nThanks to the above theorem we have now a way to compute \\(L(\\g)\\). Let us check that we have given a meaningful definition of length by computing \\(L(\\g)\\) on known examples.\n\nExample 15: Length of CircleThe circle of radius \\(R\\) is parametrized by \\(\\g \\ \\colon [0,2\\pi] \\to \\R^2\\) defined by \\[\n\\g(t) = (R\\cos(t), R\\sin(t)) \\,.\n\\] Then \\[\n\\dot \\g(t) = (-R\\sin(t), R\\cos(t))\n\\] and \\[\\begin{align}\n\\norm{\\dot\\g(t)} & = \\sqrt{ \\dot \\g_1^2(t) +   \\dot \\g_2^2(t)      } \\\\\n                & = R \\sqrt{ \\sin^2(t) + \\cos^2 (t)} = R\\,.\n\\end{align}\\] Therefore \\[\nL(\\g) = \\int_{0}^{2\\pi}  \\norm{  \\dot\\g(t)} \\, dt = \\int_0^{2\\pi} R \\, dt = 2 \\pi R\n\\] as expected.\n\n\n\nExample 16: Length of helixLet us consider one full turn of the Helix of radius \\(R\\) and rise \\(H\\). This is parametrized by \\[\n\\g(t) = (R\\cos(t), R\\sin(t) ,Ht)\n\\] for \\(t \\in [0,2\\pi]\\). Then \\[\n\\dot \\g(t) = (-R\\sin(t), R\\cos(t) , H) \\,,\n\\] and \\[\\begin{align}\n\\norm{ \\dot \\g(t)  } & = \\sqrt{  \\dot\\g_1^2 + \\dot\\g_2^2 + \\dot\\g_3^2 } \\\\\n                    & = \\sqrt{ R^2\\sin^2(t) + R^2\\cos^2(t) + H^2 } = \\sqrt{R^2 + H^2} \\,.\n\\end{align}\\] Therefore \\[\nL(\\g) = \\int_0^{2\\pi} \\norm{ \\dot\\g(t) } \\, dt = 2 \\pi \\sqrt{R^2 + H^2} \\,.\n\\]"
  },
  {
    "objectID": "sections/chap_3.html#arc-length",
    "href": "sections/chap_3.html#arc-length",
    "title": "3  Parametrized curves",
    "section": "3.3 Arc-length",
    "text": "3.3 Arc-length\nWe have just shown in Theorem 14 that the length of a regular curve \\(\\g \\ \\colon [a,b] \\to \\R^n\\) with \\([a,b]\\) bounded is given by \\[\nL(\\g) = \\int_a^b \\norm{ \\dot\\g (t)} \\,dt \\,.\n\\] Using this formula, we introduce the notion of length of a portion of \\(\\g\\).\n\nDefinition 17: Arc-lengthLet \\(\\g \\, \\colon (a,b) \\to \\R^n\\) be a curve, with \\((a,b)\\) possibly unbounded. We define the arc-length of \\(\\g\\) starting at the point \\(\\g(t_0)\\) as the function \\(s \\colon \\R \\to \\R\\) defined by \\[\ns(t) := \\int_{t_0}^t  \\norm{  \\dot\\g(\\tau) }\\, d\\tau \\,.\n\\]\n\n\n\n\n\nArc-length of \\(\\g\\) starting at \\(\\g(t_0)\\)\n\n\n\nRemark 18\nA few remarks:\n\nArc-length is well-defined\n\nIndeed, \\(\\g\\) is smooth, and so \\(\\dot \\g\\) is continuous. WLOG assume \\(t \\geq t_0\\). Then \\[\ns(t) = \\int_{t_0}^t  \\norm{  \\dot\\g(\\tau) }\\, d\\tau \\leq (t-t_0) \\max_{ \\tau \\in [t_0,t] } \\norm{\\dot\\g(\\tau)} &lt; \\infty \\,.\n\\]\n\nWe always have \\[\ns(t_0)=0\\,.\n\\]\nWe have \\[\nt &gt; t_0   \\implies  s(t) \\geq 0\n\\] and \\[\nt &lt; t_0   \\implies  s(t) \\leq 0 \\,.\n\\]\nChoosing a different starting point changes the arc-length by a constant:\n\nFor example define \\(\\tilde{s}\\) as the arc-length starting from \\(\\tilde{t}_0\\) \\[\n\\tilde{s}(t) := \\int_{\\tilde{t}_0}^t \\norm{ \\dot\\g(\\tau) } \\, d\\tau  \\,.\n\\] Then by the properties of integral \\[\\begin{align}\ns(t) & = \\int_{t_0}^t \\norm{ \\dot\\g(\\tau) } \\, d\\tau \\\\\n& = \\int_{t_0}^{\\tilde{t}_0} \\norm{ \\dot\\g(\\tau) } \\, d\\tau +\n\\int_{\\tilde{t}_0}^{t} \\norm{ \\dot\\g(\\tau) } \\, d\\tau \\\\\n& = \\int_{t_0}^{\\tilde{t}_0} \\norm{ \\dot\\g(\\tau) } \\, d\\tau + \\tilde{s}(t) \\,.\n\\end{align}\\] Hence \\[\ns = c + \\tilde{s}\n\\] with \\[\nc := \\int_{t_0}^{\\tilde{t}_0} \\norm{ \\dot\\g(\\tau) } \\, d\\tau \\,.\n\\] Note that \\(c\\) is the arc-length of \\(\\g\\) between the starting points \\(\\g(t_0)\\) and \\(\\g(\\tilde{t}_0)\\).\n\nThe arc-length is a differentiable function, with \\[\n\\dot s(t) = \\frac{d}{dt} \\int_{t_0}^t \\norm{\\dot\\g (\\tau)} \\, d\\tau =\n\\norm{\\dot\\g (t)} \\,.\n\\]\n\nSince \\(\\dot\\g\\) is continuous, the above follows by the Fundamental Theorem of Calculus.\n\n\n\n\n\nExample 19: CircleThe circle of radius \\(R\\) is parametrized by \\(\\g \\ \\colon [0,2\\pi] \\to \\R^2\\) defined by \\[\n\\g(t) = (R\\cos(t), R\\sin(t)) \\,.\n\\] Then \\[\n\\dot \\g(t) = (-R\\sin(t), R\\cos(t)) \\,, \\quad \\norm{\\dot\\g(t)} = R \\,.\n\\] Therefore, for any fixed \\(t_0 \\in [0,2\\pi]\\) we have \\[\ns(t) = \\int_{t_0}^{t}  \\norm{  \\dot\\g(\\tau)} \\, d\\tau = \\int_{t_0}^{t} R \\, d\\tau = (t - t_0)  R \\,.\n\\] In particular we see that \\(\\dot s = R\\) is constant.\n\n\n\nExample 20: Logarithmic spiralThe Logarithmic spiral is defined by \\(\\g \\ \\colon [0,2\\pi] \\to \\R^2\\) with \\[\n\\g(t) = (e^{kt} \\cos(t), e^{kt} \\sin(t)) \\,,\n\\] where \\(k \\in \\R\\), \\(k \\neq 0\\), is called the growth factor. Then \\[\n\\dot \\g_1(t) = e^{kt} ( k \\cos(t) - \\sin(t) )\n\\] \\[\n\\dot \\g_2(t) = e^{kt} ( k \\sin(t) + \\cos(t) )\n\\] and so, after some calculations, \\[\n\\norm{\\dot\\g(t)}^2   =  \\dot\\g_1^2 + \\dot\\g_2^2 = (k^2 + 1) e^{2kt} \\,.\n\\] The arc-length starting from \\(t_0\\) is \\[\\begin{align}\ns(t) & = \\int_{t_0}^t \\norm{\\dot\\g(\\tau)} \\, d \\tau \\\\\n     & = \\sqrt{k^2 + 1} \\int_{t_0}^t e^{k \\tau} \\, d \\tau  \\\\\n     & = \\frac{\\sqrt{k^2 + 1}}{k} ( e^{kt} - e^{k t_0} ) \\,.\n\\end{align}\\]\n\n\n\n\n\n\n\nFigure 3.6: Plot of Logarithmic Spiral with \\(k=0.1\\)"
  },
  {
    "objectID": "sections/chap_3.html#scalar-product-in-rn",
    "href": "sections/chap_3.html#scalar-product-in-rn",
    "title": "3  Parametrized curves",
    "section": "3.4 Scalar product in \\(\\R^n\\)",
    "text": "3.4 Scalar product in \\(\\R^n\\)\nLet us start by defining the scalar product in \\(\\R^2\\).\n\nDefinition 21: Scalar product in \\(\\R^2\\)Let \\(u, v \\in \\R^2\\) and denote by \\(\\theta \\in [0,\\pi]\\) the angle formed by \\(u\\) and \\(v\\). The scalar product between \\(u\\) and \\(v\\) is defined by \\[\nu \\cdot v := |u| |v| \\cos(\\theta) \\,.\n\\]\n\n\n\n\n\nVectors \\(u\\) and \\(v\\) in \\(\\R^2\\) forming angle \\(\\theta\\)\n\n\n\nRemark 22The scalar product is maximized for \\(\\theta = 0\\), for which we have \\[\nu \\cdot v = |u| |v| \\cos(\\theta) =  |u| |v| \\,.\n\\] It is instead minimized for \\(\\theta = \\pi\\), for which \\[\nu \\cdot v = |u| |v| \\cos(\\theta) =  -|u| |v| \\,.\n\\]\n\n\n\nDefinition 23: Orthogonal vectorsLet \\(u, v \\in \\R^2\\). If \\[\nu \\cdot v = 0\n\\] we say that \\(u\\) and \\(v\\) are orthogonal.\n\n\n\nProposition 24: Bilinearity and symmetry of scalar product\nLet \\(u, v, w \\in \\R^2\\) and \\(\\lambda \\in \\R\\). Then\n\nSymmetry: \\(u \\cdot v = v \\cdot u\\)\nBilinearity: It holds \\[\n\\lambda (u \\cdot v) = (\\lambda u) \\cdot v = u \\cdot (\\lambda v) \\,,\n\\] \\[\nu \\cdot (v + w) = u \\cdot v  + u \\cdot w \\,.\n\\]\n\n\n\nWe leave the proof to the reader. The above proposition is saying that the scalar product is bilinear and symmetric.\n\nProposition 25: Scalar products written wrt euclidean coordinatesDenote by \\[\ne_1 = (1,0) \\,, \\quad e_2 = (0,1)\n\\] the euclidean basis of \\(\\R^2\\). Let \\(u,v \\in \\R^2\\) and denote by \\[\nu = (u_1,u_2) = u_1 e_1 + u_2 e_2\n\\] \\[\nv = (v_1,v_2) = v_1 e_1 + v_2 e_2\n\\] their coordinates with respect to \\(e_1,e_2\\). Then \\[\nu \\cdot v = u_1v_2 + u_2 v_2 \\,.\n\\]\n\n\n\nProofNote that \\[\ne_1 \\cdot e_1 = 1 \\,, \\quad e_2 \\cdot e_2 = 1 \\,, \\quad\ne_1 \\cdot e_2 = e_2 \\cdot e_1 = 0 \\,.\n\\] Using the bilinearity of scalar product we have \\[\\begin{align}\nu \\cdot v & = (u_1 e_1 + u_2 e_2) \\cdot (v_1 e_1 + v_2 e_2) \\\\\n          & = u_1 v_1 e_1 \\cdot e_1 +  u_1 v_2 e_1 \\cdot e_2 +\n              u_2 v_1 e_2 \\cdot e_1 + u_2 v_2  e_2 \\cdot e_2 \\\\\n          & = u_1 v_1  + u_2 v_2 \\,.\n\\end{align}\\]\n\n\nThe above proposition provides a way to generalize of the scalar product to \\(\\R^n\\)..\n\nDefinition 26: Scalar product in \\(\\R^n\\)Let \\(u,v \\in \\R^n\\) and denote their coordinates by \\[\nu = (u_1, \\ldots, u_n) \\,, \\quad\nu = (v_1, \\ldots, v_n) \\,.\n\\] We define the scalar product between \\(u\\) and \\(v\\) by \\[\nu \\cdot v := \\sum_{i=1}^n u_i v_i \\,.\n\\]\n\n\nWith the above definition we still have that the scalar product is bilinear and symmetric, as detailed in the following proposition:\n\nProposition 27: Bilinearity and symmetry of scalar product in \\(\\R^n\\)\nLet \\(u, v, w \\in \\R^n\\) and \\(\\lambda \\in \\R\\). Then\n\nSymmetry: \\(u \\cdot v = v \\cdot u\\)\nBilinearity: It holds \\[\n\\lambda (u \\cdot v) = (\\lambda u) \\cdot v = u \\cdot (\\lambda v) \\,,\n\\] \\[\nu \\cdot (v + w) = u \\cdot v  + u \\cdot w \\,.\n\\]\n\n\n\nThe proof of the above proposition is an easy check, and is left to the reader for exercise.\n\nDefinition 28Let \\(u,v \\in \\R^n\\). We say that \\(u\\) and \\(v\\) are orthogonal if \\[\nu \\cdot v = 0 \\,.\n\\]\n\n\n\nProposition 29: Differentiating scalar productLet \\(\\g , \\eeta \\ \\colon (a,b) \\to \\R^n\\) be parametrized curves. Then the scalar map \\[\n\\g \\cdot \\eeta \\ \\colon (a,b) \\to \\R\n\\] is smooth, and \\[\n\\frac{d}{dt} (\\g \\cdot \\eeta)  = \\dot\\g \\cdot \\eeta + \\g \\cdot \\dot \\eeta\n\\] for all \\(t \\in (a,b)\\).\n\n\n\nProofDenote by \\[\n\\g = (\\g_1 ,\\ldots , \\g_n) \\,, \\quad \\eeta = (\\eta_1, \\ldots , \\eta_n)\n\\] the coordinates of \\(\\g\\) and \\(\\eeta\\). Clearly the map \\[\nt \\mapsto \\g \\cdot \\eeta = \\sum_{i=1}^n \\g_i \\eta_i\n\\] is smooth, being sum and product of smooth functions.\nConcerning the formula, by definition of scalar product and linearity of the derivative we have \\[\\begin{align}\n\\frac{d}{dt} (\\g \\cdot \\eeta) & = \\frac{d}{dt} \\left( \\sum_{i=1}^n \\g_i \\eta_i \\right) \\\\\n& = \\sum_{i=1}^n \\frac{d}{dt} ( \\g_i \\eta_i ) \\\\\n& = \\sum_{i=1}^n  \\dot\\g_i \\eta_i + \\g_i \\dot\\eta_i \\\\\n& = \\dot\\g \\cdot \\eeta + \\g \\cdot \\dot\\eeta \\,,\n\\end{align}\\] where in the second to last equality we used the product rule of differentiation."
  },
  {
    "objectID": "sections/chap_3.html#speed-of-a-curve",
    "href": "sections/chap_3.html#speed-of-a-curve",
    "title": "3  Parametrized curves",
    "section": "3.5 Speed of a curve",
    "text": "3.5 Speed of a curve\nGiven a curve \\(\\g\\) we defined the tangent vector at \\(\\g(t)\\) to be \\[\n\\dot \\g (t) \\,.\n\\] The tangent vector measures the change of direction of the curve. Therefore the magnitude of \\(\\dot \\g\\) can be interpreted as the speed of the curve.\n\nDefinition 30Let \\(\\g \\ \\colon (a,b) \\to \\R^n\\) be a curve. We define the speed of \\(\\g\\) at the point \\(\\g(t)\\) by \\[\n\\norm{\\dot \\g (t)} \\,.\n\\] We say that \\(\\g\\) is a unit-speed curve if \\[\n\\norm{\\dot \\g (t)}  = 1 \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\]\n\n\n\nRemark 31The derivative of the arc-length \\(s\\) gives the speed of \\(\\g\\): \\[\ns(t) := \\int_{t_0}^t \\norm{  \\dot\\g (\\tau) } \\, d\\tau  \\,\\, \\implies \\,\\,\n\\dot s(t) = \\norm{  \\dot\\g (t) } \\,.\n\\]\n\n\nThe reason why we introduce unit speed curves is because they make calculations easy. This is essentially because of the next proposition.\n\nProposition 32Let \\(\\g \\ \\colon (a,b) \\to \\R^n\\) be a unit speed curve. Then \\[\n\\dot \\g \\cdot \\ddot \\g = 0\n\\] for all \\(t \\in (a,b)\\).\n\n\n\nProofLet us consider the identity \\[\n\\dot \\g(t) \\cdot \\dot \\g(t) = \\sum_{i=1}^n \\dot\\g_i^2(t) = \\norm{\\dot\\g(t)}^2 \\,.\n\\tag{3.11}\\] Since \\(\\g\\) is unit speed we have \\[\n\\norm{\\dot\\g(t)}^2 = 1 \\quad \\forall \\, t \\in (a,b) \\,.\n\\] and therefore \\[\n\\frac{d}{dt} \\left( \\norm{\\dot\\g(t)}^2 \\right) = 0  \\quad \\forall \\, t \\in (a,b) \\,.\n\\tag{3.12}\\] We can differentiate the LHS of (3.11) to get \\[\n\\frac{d}{dt} (\\dot \\g \\cdot \\dot \\g) = \\ddot \\g \\cdot \\dot \\g\n+  \\dot \\g \\cdot \\ddot \\g = 2 \\dot \\g \\cdot \\ddot \\g\\,.\n\\tag{3.13}\\] where we used Proposition 29 and symmetry of the scalar product. Differentiating (3.11) and using (3.12)-(3.13) we conclude \\[\n2 \\dot \\g \\cdot \\ddot \\g = 0 \\quad \\forall \\, t \\in (a,b) \\,.\n\\]\n\n\n\nRemark 33Proposition 32 is saying that if \\(\\g\\) is unit speed, then its tangent vector \\(\\dot \\g\\) is always orthogonal to the second derivative \\(\\ddot \\g\\). This will be very useful in the future.\n\n\n\n\n\nIf \\(\\g\\) is unit speed then \\(\\dot \\g\\) and \\(\\ddot \\g\\) are orthogonal"
  },
  {
    "objectID": "sections/chap_3.html#reparametrization",
    "href": "sections/chap_3.html#reparametrization",
    "title": "3  Parametrized curves",
    "section": "3.6 Reparametrization",
    "text": "3.6 Reparametrization\nAs we have observed in the Examples of Chapter 1, there is in general no unique way to parametrize a curve. However we would like to understand when two parametrizations are related. In other words, we want to clarify the concept of equivalence of two parametrizations.\n\nDefinition 34: Diffeomorphism\nLet \\(\\f \\ \\colon (a,b) \\to (\\tilde{a},\\tilde{b})\\). We say that \\(\\f\\) is a diffeomorphism if the following conditions are satisfied:\n\n\\(\\f\\) is invertible, with inverse \\(\\f^{-1} \\ \\colon (\\tilde{a},\\tilde{b}) \\to (a,b)\\). Thus \\[\n\\f^{-1} \\circ \\f =   \\f \\circ \\f^{-1} = \\id \\,,\n\\] where \\(\\id \\colon \\R \\to \\R\\) is the identity map on \\(\\R\\), that is, \\[\n\\id(t) = t \\,, \\quad \\forall \\, t \\in \\R \\,.\n\\]\n\\(\\f\\) is smooth,\n\\(\\f^{-1}\\) is smooth.\n\n\n\n\nDefinition 35: ReparametrizationLet \\(\\g \\ \\colon (a,b) \\to \\R^n\\) be a parametrized curve. A reparametrization of \\(\\g\\) is another parametrized curve \\(\\tilde{\\g} \\ \\colon (\\tilde{a},\\tilde{b}) \\to \\R^n\\) such that \\[\n\\tg (t) = \\g (\\f(t)) \\quad \\forall \\, t \\in (\\tilde{a},\\tilde{b})\\,,\n\\tag{3.14}\\] where \\[\n\\f \\colon (\\tilde{a},\\tilde{b}) \\to (a,b)\n\\] is a diffeomerphism. We call both \\(\\f\\) and \\(\\f^{-1}\\) reparametrization maps.\n\n\n\nRemark 36A comment about the above definition. Given a parametrized curve \\(\\g\\), this identifies a 1D shape \\(\\Gamma \\subset \\R^n\\). A reparametrization \\(\\tg\\) is just an equivalent way to describe \\(\\Gamma\\). For \\(\\g\\) and \\(\\tg\\) to be reparametrizations of each other, there must exist a smooth rule \\(\\f\\) to switch from one to another, according to formula (3.14)\n\n\n\n\n\nSketch of 1D shaper parametrized by \\(\\g\\) and \\(\\tg\\)\n\n\n\nExample 37: Change of orientationThe map \\(\\f \\colon (\\tilde{a},\\tilde{b}) \\to (a,b)\\) defined by \\[\n\\f (t) := - t\n\\] is a diffeomoprhism. The inverse of \\(\\f\\) is given by \\({\\f}^{-1} \\colon (a,b) \\to (\\tilde{a},\\tilde{b})\\) defined by \\[\n{\\f}^{-1} (t) = - t \\,.\n\\] Note that \\(\\f\\) can be used to reverse the orientation of a curve.\n\n\n\nExample 38: Reversing orientation of circleConsider the unit circle parametrized as usual by \\(\\g \\ \\colon [0,2\\pi] \\to \\R^2\\) defined as \\[\n\\g (t) := (\\cos (t), \\sin(t)) \\,.\n\\] To reverse the orientation we can reparametrize \\(\\g\\) by using the diffeomorphism \\[\n\\f(t):= - t \\,.\n\\] This way we obtain \\(\\tilde{\\g}:= \\g \\circ \\f \\ \\colon [0,2\\pi] \\to [0, 2\\pi]\\), \\[\\begin{align}\n\\tilde{\\g}(t) & = \\g (\\f(t)) \\\\\n              & = (\\cos(-t),\\sin(-t)) \\\\\n              & = (\\cos(t),-\\sin(t)) \\,,\n\\end{align}\\] where in the last identity we used the properties of \\(\\cos\\) and \\(\\sin\\). Notice that in this way, for example, \\[\n\\g(\\pi/2) = (0,1) \\,, \\quad \\g(\\pi/2) = (0,-1) \\,.\n\\]\n\n\n\n\n\nUnit circle with usual parametrization \\(\\g\\), and with reversed orientation \\(\\tg\\)\n\n\n\nExample 39: Change of speed\nLet \\(k &gt; 0\\). The map \\(\\f \\colon (\\tilde{a},\\tilde{b}) \\to (a,b)\\) defined by \\[\n\\f (t) := kt\n\\] is a diffeomoprhism. The inverse of \\(\\f\\) is given by \\({\\f}^{-1} \\colon (a,b) \\to (\\tilde{a},\\tilde{b})\\) defined by \\[\n{\\f}^{-1} (t) = \\frac{t}{k} \\,.\n\\] Note that \\(\\f\\) can be used to change the speed of a curve:\n\nIf \\(k &gt; 1\\) the speed increases ,\nIf \\(0 &lt; k &lt; 1\\) the speed decreases.\n\n\n\n\nExample 40: Doubling the speed of Lemniscate\nRecall the Lemniscate \\[\n\\g (t): = (\\sin(t), \\sin(t)\\cos(t) ) \\,, \\quad t \\in [0,2\\pi] \\,.\n\\] We can double the speed of the Lemniscate by using the Using the diffeomorphism \\[\n\\f(t):=2t \\,.\n\\] This way we obtain \\(\\tilde{\\g}:= \\g \\circ \\f \\ \\colon [0,\\pi] \\to [0, 2\\pi]\\) with \\[\n\\tg (t) = \\g (\\f(t)) = (\\sin(2t), \\sin(2t)\\cos(2t)) \\,.\n\\] In this case we have that \\[\n\\dot{\\tg}(t) = 2 \\dot \\g(\\f(t)) \\,.\n\\]\n\nThe above follows by chain rule. Indeed, \\(\\dot\\f = 2\\), so that \\[\n\\dot{\\tg}  = \\frac{d}{dt} \\left(  \\g(\\f(t))  \\right)  = \\dot\\f(t) \\dot\\g (\\f(t)) = 2 \\dot\\g (\\f(t))\\,.\n\\]\n\n\n\n\n\n\nLemniscate curve \\(\\g\\) and Lemniscate at double speed \\(\\tg\\)\n\n\n\nImportantThe main reason we are interested in reparametrizations is because we want to parametrize curves by arc-lenght: This means that, for a curve \\(\\g\\), we want to find a reparametrization \\(\\tg\\) such that \\(\\tg\\) is unit speed: \\[\n\\norm{ \\dot{\\tg} } = 1 \\,, \\quad  \\forall t \\in (a,b) \\,.\n\\] We will see that this is not always possible.\n\n\n\nDefinition 41: Regular points\nLet \\(\\g \\ \\colon (a,b) \\to \\R^n\\) be a parametrized curve. We say that:\n\n\\(\\g(t_0)\\) is a regular point if \\[\n\\dot\\g(t_0) \\neq 0 \\,.\n\\]\nA point \\(\\g(t_0)\\) is singular if it is not regular.\nThe curve \\(\\g\\) is regular if every point of \\(\\g\\) is regular, that is, \\[\n\\dot\\g(t) \\neq 0 \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\]\n\n\n\nNote that when \\(\\dot\\g(t_0) = 0\\), this means the curve is stopping at time \\(t_0\\). Before making an example, let us prove a useful lemma about diffeomorphisms.\n\nLemma 42Let \\(\\f \\ \\colon (a,b) \\to (\\tilde{a},\\tilde{b})\\) be a diffeomorphism. Then \\[\n\\dot\\f (t) \\neq 0 \\quad \\forall \\, t \\in (a,b) \\,.\n\\]\n\n\n\nProofWe know that \\(\\f\\) is smooth with smooth inverse \\[\n\\psi := \\f^{-1} \\ \\colon (\\tilde{a},\\tilde{b}) \\to (a,b) \\,.\n\\] In particular it holds \\[\n\\psi (\\f(t)) = t \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\] We can differentiate both sides of the above expression to get \\[\n\\frac{d}{dt} \\left( \\psi (\\f(t))  \\right) = 1 \\,.\n\\tag{3.15}\\] We can differentiate the LHS by chain rule \\[\n\\frac{d}{dt} \\left( \\psi (\\f(t))  \\right) = \\dot\\psi (\\f(t)) \\, \\dot\\f(t) \\,.\n\\] From (3.15) we then get \\[\n\\dot\\psi (\\f(t)) \\, \\dot\\f(t) = 1 \\, , \\quad \\forall \\, t \\in (a,b) \\,.\n\\] Since on the LHS we have a product, this means that none of the LHS terms vanishes, so that \\[\n\\dot\\f(t) \\neq  0 \\, , \\quad \\forall \\, t \\in (a,b) \\,.\n\\]\n\n\n\nExample 43: A curve with one singular point\nConsider the parabola \\[\n\\Gamma := \\{ (x,y) \\in \\R^2 \\, \\colon \\,  y=x^2 , \\, -1 \\leq x \\leq 1\\} \\,.\n\\] This can be parametrized in two ways by \\(\\g, \\eeta \\ \\colon [-1,1] \\to \\R^2\\) defined as \\[\n\\g (t) = (t,t^2) \\,, \\quad\n\\eeta(t) = (t^3, t^6) \\,.\n\\] We will see that the above parametrizations are not equivalent. This is intuitively clear, since the change of variables map should be \\[\n\\f(t) = t^3 \\,.\n\\] This is smooth and invertible, with inverse \\[\n\\f^{-1}(t) = \\sqrt[3]{x} \\,.\n\\] However \\(\\f^{-1}\\) is not smooth at \\(t=0\\), and thus \\(\\f\\) is not a diffeomorphism. Alternatively we could have just noticed that \\[\n\\dot \\f (t) = 3t^2 \\quad \\implies \\quad \\dot\\f(0) = 0 \\,,\n\\] and therefore \\(\\f\\) cannot be a diffeomorphism due to Lemma 42.\nLet us look at the derivatives: \\[\n\\dot \\g (t) = (1,2t) \\,, \\quad \\dot \\eeta (t)= (3t^2,6t^5) \\,.\n\\] We notice a difference:\n\n\\(\\g\\) is a regular parametrization,\n\\(\\eeta(t)\\) is regular only for \\(t \\neq 0\\).\n\nIndeed if we animate the plots of the above parametrizations, we see that:\n\nThe point \\(\\g(t)\\) moves with constant horizontal speed\nThe point \\(\\eeta(t)\\) is decelerating for \\(t &lt; 0\\), it stops at \\(t = 0\\), and then accelerates again for \\(t&gt;0\\).\n\n\n\n\n\n\nLeft: Animation of \\(\\g\\). Right: Animation of \\(\\eeta\\)\n\n\n\nProposition 44: Regularity is invariant for reparametrizationLet \\(\\g \\ \\colon (a,b) \\to \\R^n\\) be a parametrized curve and suppose that \\(\\g\\) is regular, that is, \\[\n\\dot\\g(t) \\neq 0 \\,, \\quad  \\forall \\, t \\in (a,b) \\,.\n\\] Then every reparametrization of \\(\\g\\) is also regular.\n\n\n\nProofLet \\(\\tg \\ \\colon (\\tilde{a},\\tilde{b}) \\to \\R^n\\) be a reparametrization of \\(\\g\\). Then there exist \\(\\f \\ \\colon (\\tilde{a},\\tilde{b}) \\to (a,b)\\) diffeomorphism such that \\[\n\\tilde \\g (t) = \\g (\\f (t)) \\,, \\quad \\forall \\, t \\in (\\tilde{a},\\tilde{b}) \\,.\n\\] By the chain rule we have \\[\n\\dot{\\tg}(t) = \\frac{d}{dt}  \\left(  \\g (\\f(t))  \\right) = \\dot\\g (\\f(t)) \\dot\\f(t) \\,.\n\\] Therefore \\[\n\\dot{\\tg}(t) \\neq 0 \\quad \\iff \\quad \\dot\\g (\\f(t)) \\dot\\f(t)  \\neq 0 \\,.\n\\tag{3.16}\\] But we are assuming that \\(\\g\\) is regular, so that \\[\n\\dot\\g (\\f(t)) \\neq 0 \\,, \\quad \\forall\\, t \\in (\\tilde{a},\\tilde{b}) \\,.\n\\] Thus (3.16) is equivalent to \\[\n\\dot{\\tg}(t) \\neq 0 \\quad \\iff \\quad  \\dot\\f(t)  \\neq 0 \\,.\n\\tag{3.17}\\] Since \\(\\f\\) is a diffeomorphism, by Lemma 42 we have that \\[\n\\dot \\f (t) \\neq 0 \\,, \\quad \\forall\\, t \\in (\\tilde{a},\\tilde{b})  \\,.\n\\] By (3.17) we conclude that \\[\n\\dot{\\tg}(t) \\neq  0 \\, , \\quad \\forall \\, t \\in (\\tilde{a},\\tilde{b}) \\,,\n\\] proving that \\(\\tg\\) is regular.\n\n\n\nExample 45Let us go back to the parabola \\[\n\\Gamma := \\{ (x,y) \\in \\R^2 \\, \\colon \\,  y=x^2 , \\, -1 \\leq x \\leq 1\\} \\,,\n\\] with the two parametrizations \\(\\g, \\eeta \\ \\colon [-1,1] \\to \\R^2\\) with \\[\n\\g (t) = (t,t^2) \\,, \\quad\n\\eeta(t) = (t^3, t^6) \\,.\n\\] We have that \\[\n\\dot \\g (t) = (1,2t) \\,, \\quad \\dot \\eeta (t)= (3t^2,6t^5) \\,.\n\\] Therefore\n\n\\(\\g\\) is a regular parametrization,\n\\(\\eeta(t)\\) is regular only for \\(t \\neq 0\\).\n\nProposition 44 implies that \\(\\eeta\\) is NOT a reparametrization of \\(\\g\\).\n\n\n\nDefinition 46: Unit speed reparametrizationLet \\(\\g\\) be a parametrized curve. A unit speed reparametrization of \\(\\g\\) is a reparametrization \\(\\tg\\) such that \\(\\tg\\) is unit speed.\n\n\nThe next theorem states that a curve is regular if and only if it has a unit speed reparametrization. For the proof, it is crucial to recall the definition of arc-length of a curve \\(\\g \\colon (a,b) \\to \\R^n\\), which is given by \\[\ns(t):=\\int_{t_0}^t \\norm{ \\dot \\g (\\tau) } \\, d\\tau \\,,\n\\] for some arbitrary \\(t_0 \\in (a,b)\\) fixed. Indeed, we will see that for \\(\\f\\) regular the unit speed parametrization map can be taken as \\[\n\\f = s^{-1} \\,.\n\\]\n\nTheorem 47: Existence of unit speed reparametrization\nLet \\(\\g\\) be a parametrized curve. They are equivalent:\n\n\\(\\g\\) is regular,\n\\(\\g\\) has a unit speed reparametrization.\n\n\n\n\nProofStep 1. Direct implication.\nAssume \\(\\g \\ \\colon (a,b) \\to \\R^n\\) is regular, that is, \\[\n\\dot \\g (t) \\neq 0 \\,, \\quad \\forall \\, t \\in (a,b)\\,.\n\\] Let \\(s \\ \\colon (a,b) \\to \\R\\) be the arc-length of \\(\\g\\) starting at any point \\(t_0 \\in (a,b)\\). By the Fundamental Theorem of Calculus we have \\[\n\\dot s (t) = \\norm{ \\dot \\g(t) }  \n\\tag{3.18}\\] so that \\[\n\\dot s (t) &gt; 0 \\,, \\quad \\forall \\, t \\in (a,b)\\,.\n\\] Since \\(s\\) is a scalar function, the above condition and the Inverse Function Theorem guarantee the existsence of a smooth inverse \\[\ns^{-1} \\ \\colon (\\tilde{a},\\tilde{b}) \\to (a,b)\n\\] for some \\(\\tilde{\\alpha}&lt; \\tilde{\\beta}\\). Define the reparametrization map \\(\\f\\) as \\[\n\\f := s^{-1}\n\\] and the corresponding reparametrization of \\(\\g\\) given by the curve \\[\n\\tg \\ \\colon  (\\tilde{a},\\tilde{b}) \\to \\R^n \\,, \\quad\n\\tg := \\g \\circ \\f \\,.\n\\] We claim that \\(\\tg\\) is unit speed. Indeed, by definition \\[\n\\tg := \\g \\circ \\f \\quad \\implies \\quad \\g = \\tg \\circ \\f^{-1} = \\tg \\circ s \\,,\n\\] or in other words \\[\n\\g(t) = \\tg (s(t)) \\,, \\quad \\forall t \\in (a,b) \\,.\n\\] Differentiating the above expression and using the chain rule we get \\[\n\\dot \\g (t) = \\dot{\\tg}(s(t)) \\, \\dot s(t) =  \\dot{\\tg}(s(t)) \\, \\norm{ \\dot \\g(t) }  \n\\] where in the last equality we used (3.18). Taking the absolute value of the above yileds \\[\n\\norm{ \\dot \\g(t) }   = \\norm{\\dot{\\tg}(s(t))} \\, \\norm{ \\dot \\g(t) } \\,.  \n\\tag{3.19}\\] Since \\(\\g\\) is regular, we have \\[\n\\norm{\\dot \\g (t)} \\neq 0 \\,, \\quad \\forall \\, t \\in (a,b)\\,.\n\\] Therefore we can divide (3.19) by \\(\\norm{\\dot\\g(t)}\\) and obtain \\[\n\\norm{\\dot{\\tg}(s(t))} = 1  \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\] By invertibility of \\(s\\), the above holds if and only if \\[\n\\norm{\\dot{\\tg}(t)} = 1  \\,, \\quad \\forall \\, t \\in (\\tilde{a},\\tilde{b}) \\,,\n\\] showing that \\(\\tg\\) is a unit speed reparametrization of \\(\\g\\).\nStep 2. Reverse implication.\nSuppose there exists a unit speed reparametrization of \\(\\g\\) denoted by \\[\n\\tg \\ \\colon (\\tilde{a},\\tilde{b})  \\to \\R^n \\,, \\quad \\tg = \\g \\circ \\f\n\\] for some reparametrization map \\(\\f \\ \\colon (\\tilde{a},\\tilde{b}) \\to (a,b)\\). Differentiating \\(\\tg = \\g \\circ \\f\\) and using the chain rule we get \\[\n\\dot{\\tg}(t) = \\dot{\\g} (\\f(t)) \\, \\dot \\f(t) \\,.\n\\] Taking the norm \\[\n\\norm{\\dot{\\tg}(t)} = \\norm{\\dot{\\g} (\\f(t)) } \\, |\\dot \\f (t)| \\,.\n\\] Since \\(\\tg\\) is unit speed we obtain \\[\n\\norm{\\dot{\\g} (\\f(t)) } \\, |\\dot \\f (t)| = 1 \\,, \\quad \\forall \\, t \\in (\\tilde{a},\\tilde{b}) \\,.\n\\tag{3.20}\\] Since \\(\\f\\) is a diffeomorphism from \\((\\tilde{a},\\tilde{b})\\) into \\((a,b)\\), Lemma 42 guarantees that \\[\n\\dot{\\f} (t)  \\neq 0 \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\] In particular (3.20) implies \\[\n\\dot{\\g} (\\f(t))  \\neq 0 \\,, \\quad \\forall \\, t \\in (\\tilde{a},\\tilde{b}) \\,.\n\\] As \\(\\f\\) is invertible, we also have \\[\n\\dot{\\g} (t)  \\neq 0 \\,, \\quad \\forall \\, t \\in (a,b) \\,,\n\\] proving that \\(\\g\\) is regular.\n\n\nThe proof of Theorem 47 told us that, if \\(\\g\\) is regular, then \\[\n\\tg = \\g \\circ s^{-1}\n\\] is a unit speed reparametrization of \\(\\g\\). In the next proposition we show that the arc-length \\(s\\) is essentially the only unit-speed reparametrization of a regular curve.\n\nProposition 48: Arc-length and unit speed reparametrization\nLet \\(\\g \\ \\colon (a,b) \\to \\R^n\\) be a regular curve. Let \\(\\tg \\ \\colon (\\tilde{a},\\tilde{b}) \\to \\R^n\\) be reparametrization of \\(\\g\\), so that \\[\n\\g(t) = \\tg ( \\f(t) )  , \\quad \\forall \\, t \\in (a,b)\\,.\n\\] for some diffeomorphism \\(\\f \\ \\colon (a,b) \\to (\\tilde{a},\\tilde{b})\\). Denote by \\[\ns(t):= \\int_{t_0}^t  \\norm{\\dot\\g(\\tau)} \\, d \\tau \\,, \\quad t \\in (a,b)\n\\] the arc-length of \\(\\g\\) starting at any point \\(t_0 \\in (a,b)\\). We have:\n\nIf \\(\\tg\\) is unit speed, then there exists \\(c \\in \\R\\) such that \\[\n\\f(t) = \\pm s(t) + c   \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\tag{3.21}\\]\nIf \\(\\f\\) is given by (3.21) for some \\(c \\in \\R\\), then \\(\\tg\\) is unit speed.\n\n\n\n\nProofStep 1. First Point.\nFirst note that a unit speed reparametrization \\(\\tg\\) of \\(\\g\\) exists by Theorem 47, since \\(\\g\\) is assumed to be regular. Thus assume \\(\\tg\\) is unit speed reparametrization of \\(\\g\\). By differentiating both sides of \\[\n\\g(t) = \\tg ( \\f(t) )  , \\quad \\forall \\, t \\in (a,b)\\,,\n\\] we obtain \\[\n\\dot \\g(t) = \\frac{d}{dt} \\tg ( \\f(t) ) = \\dot{\\tg}(\\f(t)) \\, \\dot\\f(t)  \\,.\n\\] Taking the norms we then have \\[\\begin{align}\n\\norm{ \\dot \\g(t) } & = \\norm{ \\dot{\\tg}(\\f(t)) \\, \\dot\\f(t) } \\\\\n                    & = \\norm{ \\dot{\\tg}(\\f(t)) } \\, | \\dot\\f(t) | \\\\\n                    & = | \\dot\\f(t) | \\,,\n\\end{align}\\] where in the last equality we used that \\(\\tg\\) is unit speed, and so \\[\n\\norm{\\dot{\\tg}} \\equiv 1 \\,.\n\\] To summarize, so far we have proven that \\[\n\\norm{ \\dot \\g(t) }  = | \\dot\\f(t) | \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\] Therefore \\[\ns(t) = \\int_{t_0}^t \\norm{ \\dot \\g(\\tau) } \\, d\\tau =  \\int_{t_0}^t | \\dot \\f(\\tau) | \\, d\\tau \\,.\n\\] By the Fundamental Theorem of Calculus we get \\[\n\\dot s(t) = |\\dot \\f(t) |\n\\] and therefore \\[\n\\f = \\pm s + c\n\\] for some \\(c \\in \\R\\), concluding the proof.\nStep 2. Second Point.\nSuppose that \\[\n\\f := \\pm s + c\n\\] for some \\(c \\in \\R\\), so that \\(\\phi \\ \\colon (a,b) \\to (\\tilde{a},\\tilde{b})\\). We have \\[\n\\dot\\f (t) =  \\pm \\dot s (t) = \\pm \\norm{ \\dot\\g(t) } \\neq 0  \n\\tag{3.22}\\] where the last term is non-zero since \\(\\g\\) is regular. Therefore, due to the Inverse Function Theorem, \\(\\f\\) is invertible with smooth inverse. This proves that \\(\\tg\\) defined by \\[\n\\tg := \\g \\circ \\psi  \\,, \\quad \\psi := \\f^{-1} \\,,\n\\] is a reparametrization of \\(\\g\\). In particular \\[\n\\g = \\tg \\circ \\f \\,.\n\\] Differentiating the above, and recalling (3.22), we get \\[\n\\dot{\\g}(t) = \\dot{\\tg}( \\f(t) ) \\, \\dot\\f(t) = \\dot{\\tg}( \\f(t) ) \\,\\left( \\pm \\norm{ \\dot\\g(t) } \\right) \\,.\n\\] Taking the absolute value of the above yields \\[\n\\norm{ \\dot\\g(t) } = \\norm{ \\dot{\\tg}( \\f(t) )}  \\, \\norm{ \\dot\\g(t) } \\,.\n\\] Since \\(\\g\\) is regular we can divide by \\(\\norm{ \\dot\\g(t) }\\) to get \\[\n\\norm{ \\dot{\\tg}( \\f(t) )}  = 1 \\, \\quad \\forall \\, t \\in (a,b)  \\, .\n\\] Since \\(\\f\\) is invertible, the above is equivalent to \\[\n\\norm{ \\dot{\\tg}( t )}  = 1 \\, \\quad \\forall \\, t \\in (\\tilde{a},\\tilde{b})  \\, ,\n\\] proving that \\(\\tg\\) is a unit speed reparametrization.\n\n\n\nRemark 49Let \\(\\g\\) be regular. The above proposition tells us that they are equivalent:\n\nComputing a unit speed reparametrization of \\(\\g\\),\nComputing \\(s\\) the arc-length of \\(\\g\\).\n\nIn some cases however, unit speed reparametrization and arc-length are impossible to characterize in terms of elementary functions, even for very simple curves.\n\n\n\nExample 50: Twisted cubicDefine the twisted cubic \\(\\g \\ \\colon \\R \\to \\R^3\\) by \\[\n\\g(t) = (t,t^2,t^3)\\,.\n\\] Therefore \\[\n\\dot \\g(t) = (1,2t,3t^2)\\,,\n\\] so that \\[\n\\dot \\g (t) \\neq 0 \\,, \\quad \\forall \\, t \\in \\R  \\,,\n\\] meaning that \\(\\g\\) is regular. In particular we have \\[\n\\norm{ \\dot \\g(t) } = \\sqrt{  1 + 4t^2 + 9t^4 }\n\\] so that the arc-length of \\(\\g\\) is \\[\ns(t) = \\int_{t_0}^t  \\sqrt{  1 + 4\\tau^2 + 9\\tau^4 }\\, d\\tau \\,.\n\\] Since \\(\\g\\) is regular, by Proposition 48 we know that \\(\\g\\) admits a unit speed reparametrization \\(\\tg\\) such that \\[\n\\g =  \\tg \\circ \\f\n\\] with the diffeomorphism \\(\\f\\) given by \\[\n\\f(t) = \\pm s(t) + c = \\pm \\int_{t_0}^t  \\sqrt{  1 + 4\\tau^2 + 9\\tau^4 }\\, d\\tau + c\n\\] for some \\(c \\in \\R\\). It can be shown that the above integral does not have a closed form in terms of elementary functions. Therefore the unit speed parametrization \\(\\tg\\) cannot be computed explicitly.\n\n\n\n\n\n\n\nPlot of Twisted Cubic for t between -2 and 2"
  },
  {
    "objectID": "sections/chap_3.html#closed-curves",
    "href": "sections/chap_3.html#closed-curves",
    "title": "3  Parametrized curves",
    "section": "3.7 Closed curves",
    "text": "3.7 Closed curves\nSo far we have seen examples of:\n\nCurves which are infinite, or unbounded. This is for example the parabola \\[\n\\g(t) := (t,t^2) \\,, \\quad \\forall \\, t \\in \\R \\,,\n\\]\nCurves which are finite and have end-points, such as the semi-circle \\[\n\\g(t) := (\\cos(t),\\sin(t)) \\,, \\quad \\forall \\, t \\in [0,\\pi] \\,,\n\\]\nCurves which form loops, such as the circle \\[\n\\g(t) := (\\cos(t),\\sin(t)) \\,, \\quad \\forall \\, t \\in [0,2\\pi] \\,.\n\\]\n\nHowever there are examples of curves which are in between the above types.\n\nExample 51\nFor example consider the curve \\(\\g \\ \\colon \\R \\to \\R^2\\) \\[\n\\g(t) := (t^2-1, t^3 -t) \\,\\quad  \\forall \\, t \\in \\R \\,.\n\\] This curve has two main properties:\n\n\\(\\g\\) is unbounded: If define \\(\\tg\\) as the restriction of \\(\\g\\) to the time interval \\([1,\\infty)\\), then \\(\\tg\\) is unbounded. A point which starts at \\(\\g (1) = (0,0)\\) goes towards infinity.\n\\(\\g\\) contains a loop: If we define \\(\\tg\\) as the restriction of \\(\\g\\) to the time interval \\([-1,1]\\), then \\(\\tg\\) is a closed loop starting at \\(\\g (-1) = (0,0)\\) and returnning at \\(\\g (1) = (0,0)\\).\n\n\n\n\n\n\nAnimated plot of curve \\(\\g(t) = (t^2-1, t^3-1)\\) for \\(t \\in [-2,2]\\)\n\n\nThe aim of this section is to make precise the concept of looping curve. To do that, we need to define periodic curves.\n\nDefinition 52: Periodic curveLet \\(\\g \\ \\colon \\R \\to \\R^n\\) be a parametrized curve, and let \\(T \\in \\R\\). We say that \\(\\g\\) is T-periodic if \\[\n\\g(t) = \\g(t+T) \\,, \\quad \\forall \\, t \\in \\R \\,.\n\\]\n\n\nNote that every curve is \\(0\\)-periodic. Therefore to define a closed curve we need to rule out this case.\n\nDefinition 53: Closed curve\nLet \\(\\g \\ \\colon \\R \\to \\R^n\\) be a parametrized curve. We say that \\(\\g\\) is closed if:\n\n\\(\\g\\) is not constant,\n\\(\\g\\) is T-periodic for some \\(T \\neq 0\\).\n\n\n\n\nRemark 54\nWe have the following basic facts:\n\nIf \\(\\g\\) is \\(T\\)-periodic, then a point moving around \\(\\g\\) returns to its starting point after time \\(T\\).\n\nThis is exactly the definition of \\(T\\)-periodicity. Indeed let \\(p = \\g(a)\\) be the point in question, then \\[\n\\g(a + T) = \\g(a) = p\n\\] by periodicity. Thus \\(\\g\\) returns to \\(p\\) after time \\(T\\).\n\nIf \\(\\g\\) is \\(T\\)-periodic, then \\(\\g\\) is determined by its restriction to any interval of length \\(|T|\\).\nConversely, suppose that \\(\\g \\ \\colon [a,b] \\to \\R^n\\) satisfies \\[\n\\g(a) = \\g(b) \\,, \\quad \\frac{d^k \\g}{dt^k} (a) =\\frac{d^k \\g}{dt^k}  (b)  \n\\] for all \\(k \\in \\N\\). Set \\[\nT:=b-a \\,.\n\\] Then \\(\\g\\) can be extended to a \\(T\\)-periodic curve \\(\\tg \\ \\colon \\R \\to \\R^n\\) defined by \\[\n\\tg (t) := \\g (\\tilde{t}) \\,, \\quad  \\tilde{t}:= t - \\biggl\\lfloor \\frac{t-a}{b-a}  \\biggr\\rfloor (b-a)  \\,, \\quad \\forall \\, t \\in \\R \\,.\n\\] The above means that \\(\\tg(t)\\) is defined by \\(\\g(\\tilde{t})\\) where \\(\\tilde{t}\\) is the unique point in \\([a,b]\\) such that \\[\nt = \\tilde{t} + k(b-a)\n\\] with \\(k \\in \\Z\\) defined by \\[\nk := \\biggl\\lfloor \\frac{t-a}{b-a}  \\biggr\\rfloor \\,,\n\\] see figure below. In this way \\(\\tg\\) is \\(T\\)-periodic.\nIf \\(\\g\\) is \\(T\\)-periodic, then it is also \\((-T)\\)-periodic.\n\nBecause if \\(\\g\\) is \\(T\\)-periodic then \\[\n\\g (t) = \\g ((t - T) + T ) = \\g (t - T)\n\\] where in the first equality we used the trivial identity \\(t = (t-T) + T\\), while in the second equality we used \\(T\\)-periodicity of \\(\\g\\).\n\nIf \\(\\g\\) is \\(T\\)-periodic for some \\(T \\neq 0\\), then it is \\(T\\)-periodic for some \\(T&gt;0\\).\n\nThis is an immediate consequence of Point 4.\n\nIf \\(\\g\\) is \\(T\\)-periodic the \\(\\g\\) is \\((kT)\\)-periodic, for all \\(k \\in \\Z\\).\n\nBy point 4 we can assume WLOG that \\(k \\geq 0\\). We proceed by induction:\n\nThe statement is true for \\(k=1\\), since \\(\\g\\) is \\(T\\)-periodic.\nAssume now that \\(\\g\\) is \\(kT\\)-periodic. Then \\[\\begin{align}\n\\g(t + (k+1) T) & = \\g ( (t+T)  + kT ) & \\\\\n& = \\g (t + T)   &  \\mbox{(by $kT$-periodicity)} \\\\  \n& = \\g (t)   &  \\mbox{(by $T$-periodicity)}\n\\end{align}\\] showing that \\(\\g\\) is \\((k+1)T\\)-periodic.\n\n\n\nBy induction we conclude that \\(\\g\\) is \\((kT)\\)-periodic for all \\(k \\in \\N\\).\n\nIf \\(\\g\\) is \\(T_1\\)-periodic and \\(T_2\\)-periodic then \\(\\g\\) is \\((k_1T_1 + k_2 T_2)\\)-periodic, for all \\(k_1, k_2 \\in \\Z\\).\n\nBy Point 6 we know that \\(\\g\\) is \\(k_1T_1\\)-periodic and \\(k_2T_2\\)-periodic. Set \\(T:=k_1T_1 + k_2T_2\\). We have \\[\\begin{align}\n\\g(t + T) & = \\g ( (t+ k_1T_1)  + k_2T_2 ) & \\\\\n& = \\g (t + k_1T_1)  &  \\mbox{(by $k_2T_2$-periodicity)} \\\\  \n& = \\g (t)  &  \\mbox{(by $k_1T_1$-periodicity)}\n\\end{align}\\] showing that \\(\\g\\) is \\((k_1T_1 + k_2 T_2)\\)-periodic.\n\n\n\n\n\n\n\nThe points \\(t \\in \\R\\) and \\(\\tilde{t} \\in [a,b]\\) from Point 3 in Remark 54. In this skecth \\(t = \\tilde{t} + 3 T\\), with \\(T = b-a\\).\n\n\n\nDefinition 55Let \\(\\g\\) be a closed curve. The period of \\(\\g\\) is the smallest \\(T&gt;0\\) such that \\(\\g\\) is \\(T\\)-periodic, that is \\[\n\\mbox{Period of $\\g$} := \\min \\{ T \\, \\colon \\, T &gt; 0 \\,, \\,\\, \\g \\, \\mbox{ is T-periodic}    \\} \\,.\n\\]\n\n\nWe need to show that the above definition is well-posed, i.e., that there exists such smallest \\(T&gt;0\\).\n\nProposition 56Let \\(\\g\\) be a closed curve. Then there exists a smallest \\(T&gt;0\\) such that \\(\\g\\) is \\(T\\)-periodic. In other words, the set \\[\nS := \\{ T  \\, \\colon \\, T &gt; 0 \\,, \\,\\, \\g \\, \\mbox{ is T-periodic} \\} \\,.\n\\] admits positive minumum \\[\nP = \\min S \\,, \\quad P &gt; 0 \\,.\n\\]\n\n\n\nProofWe make 2 observations about the set \\(S\\):\n\nSince \\(\\g\\) is closed, we have that \\(\\g\\) is \\(T\\)-periodic for some \\(T \\neq 0\\). By Remark 54 Point 5, we know that \\(T\\) can be chosen such that \\(T&gt;0\\). Therefore \\[\nS \\neq \\emptyset \\,.\n\\]\n\\(S\\) is bounded below by \\(0\\). This is by definition of \\(S\\).\n\nThus, by the Axiom of Completeness of the Real Numbers, the set \\(S\\) admits an infimum \\[\nP = \\inf S \\,.\n\\] The proof is concluded if we show that:\nClaim. We have \\[\nP = \\min S  \\,.\n\\] This is equivalent to saying that \\[\nP \\in S \\,.\n\\]\nProof of claim.\nTo see that \\(P \\in S\\) we need to show that\n\n\\(\\g\\) is \\(P\\)-periodic,\n\\(P&gt;0\\).\n\nSince \\(P\\) is the infimum of \\(S\\), there exists an infimizing sequence \\(\\{T_n\\}_{n \\in \\N} \\subset S\\) such that \\[\nT_n \\to P \\,.\n\\] WLOG we can choose \\(T_n\\) decreasing, that is, such that \\[\nT_1 &gt; T_2 &gt; \\ldots &gt; T_n &gt; \\ldots &gt; 0 \\,.\n\\]\nProof of Point 1. As \\(T_n \\in S\\), we have that \\(\\g\\) is \\(T_n\\)-periodic. Then \\[\n\\g (t + T_n) = \\g(t) \\,, \\quad \\forall \\, t \\in \\R \\,,  \\,\\, n \\in \\N \\,.\n\\] Since \\(T_n \\to P\\), we can take the limit as \\(n \\to \\infty\\) and use the continuity of \\(\\g\\) to obtain \\[\n\\g(t) = \\lim_{n \\to \\infty} \\ \\g (t + T_n) = \\g(t + P) \\,, \\quad \\forall \\, t \\in \\R \\,,\n\\] showing that \\(\\g\\) is \\(P\\)-periodic.\nProof of Point 2. Suppose by contradiction that \\[\nP = 0 \\,.\n\\] Fix \\(t \\in \\R\\). Since \\(T_n &gt; 0\\), we can find unique \\[\nt_n \\in [0,T_n] \\,, \\quad k_n \\in \\Z \\,,\n\\] such that \\[\nt = t_n + k_n T_n \\,,\n\\] as shown in the figure below. Indeed, it is sufficient to define \\[\nk_n := \\biggl\\lfloor \\frac{t}{T_n}  \\biggr\\rfloor \\in \\Z \\,, \\quad t_n := t - k_n T_n \\,.\n\\] Since \\(T_n \\in S\\), we know that \\(\\g\\) is \\(T_n\\)-periodic. Remark 54 Point 6 implies that \\(\\g\\) is also \\(k_nT_n\\)-periodic, since \\(k_n \\in \\Z\\). Thus \\[\\begin{align}\n\\g (t) & = \\g( t_n + k_nT_n )   &   \\mbox{(definition of $t_n$)} \\\\\n       & = \\g(t_n)             & \\mbox{(by $k_nT_n$-periodicity)} \\,.\n\\end{align}\\] Therefore \\[\n\\g(t) = \\g(t_n) \\,, \\quad \\forall \\, n \\in \\N \\,.\n\\tag{3.23}\\] Also notice that \\[\n0 \\leq t_n \\leq T_n \\,, \\quad \\forall \\, n \\in \\N \\,.\n\\] by construction. Since \\(T_n \\to 0\\), by the Squeeze Theorem we conclude that \\[\nt_n \\to 0  \\quad \\mbox{as } \\, n \\to \\infty \\,.\n\\] Using the continuity of \\(\\g\\), we can pass to the limit in (3.23) and obtain \\[\n\\g(t) = \\lim_{n \\to \\infty} \\g(t_n) = \\g(0) \\,.\n\\] Since \\(t \\in \\R\\) was arbitrary, we have shown that \\[\n\\g(t) =  \\g(0) \\,, \\quad \\forall \\, t \\in \\R \\,.\n\\] Therefore \\(\\g\\) is constant. This is a contradiction, as we were assuming that \\(\\g\\) is closed, and, in particular, not constant.\n\n\n\n\n\nFor each \\(t \\in \\R\\) there exist unique \\(k_n \\in \\Z\\) and \\(\\tilde{t}_n \\in [0,T_n]\\) such that \\(t=\\tilde{t} + k_n T_n\\). In this skecth \\(k_n =3\\).\n\n\n\nExample 57\nSome examples of closed curves:\n\nThe circumference \\[\n\\g (t) = (\\cos(t), \\sin(t)) \\,, \\quad t \\in \\R\n\\] is not costant and is \\(2\\pi\\)-periodic. Thus \\(\\g\\) is closed. The period of \\(\\g\\) is \\(2 \\pi\\).\nThe Lemniscate \\[\n\\g (t) = (\\sin(t), \\sin(t) \\cos(t)) \\,, \\quad t \\in \\R\n\\] is not costant and is \\(2\\pi\\)-periodic. Thus \\(\\g\\) is closed. The period of \\(\\g\\) is \\(2 \\pi\\).\nConsider again the curve from Example 51 \\[\n\\g(t) := (t^2-1, t^3 -t) \\,, \\quad \\, t \\in \\R \\,.\n\\] According to our definition, \\(\\g\\) is not periodic. Therefore \\(\\g\\) is not closed. However there is a point of self-intersection on \\(\\g\\), namely \\[\np := (0,0) \\,,\n\\] for which we have \\[\np = \\g (-1) = \\g(1) \\,.\n\\]\n\n\n\nThe last curve in the above example motivates the definition of self-intersecting curve.\n\nDefinition 58: Self-intersecting curve\nLet \\(\\g \\ \\colon \\R \\to \\R^n\\) be a parametrized curve. We say that \\(\\g\\) is self-intersecting at a point \\(p\\) on the curve if\n\nThere exist two times \\(a \\neq b\\) such that \\[\np = \\g(a)=\\g(b)  \\,,\n\\]\nIf \\(\\g\\) is closed with period \\(T\\), then \\(b-a\\) is not an integer multiple of \\(T\\).\n\n\n\n\nRemark 59The second condition in the above definition is important: if we did not require it, then any closed curve would be self-intersecting. Indeed consider a closed curve \\(\\g \\ \\colon \\R \\to \\R^n\\) and let \\(T\\) be its period. Then by Point 6 in Remark 54 we have \\[\n\\g(a) = \\g (a + kT) \\,, \\quad \\forall \\ a \\in \\R, \\, k \\in \\Z \\,.\n\\] Therefore every point \\(\\g(a)\\) would be of self-intersection. Point 2 in the above definition rules this example out. Indeed set \\(b:=a + kT\\), then \\[\nb - a = k T \\,,\n\\] meaning that \\(b-a\\) is an integer multiple of \\(T\\).\n\n\n\nExample 60Let us go back to the curve of Example 51, that is, \\[\n\\g(t) := (t^2-1, t^3 -t) \\,, \\quad \\, t \\in \\R \\,.\n\\] We have that \\(\\g\\) is not periodic, and therefore not closed. However \\(p = (0,0)\\) is a point of self-intersection on \\(\\g\\), since we have \\[\np = \\g (-1) = \\g(1) \\,.\n\\]\n\n\n\nExample 61: The LimaçonDefine the parametrized curve \\(\\g \\ \\colon \\R \\to \\R^2\\) by \\[\n\\g(t) = ( (1+2\\cos(t)) \\cos(t) ,  (1 + 2 \\cos(t)) \\sin(t)   ) \\,,\n\\quad \\forall \\, t \\in \\R \\,.\n\\] Such curve, plotted bolow, is called limaçon (French for snail). This curve is non constant and \\(2\\pi\\)-periodic. Therefore it is closed. The period of \\(\\g\\) is \\(2 \\pi\\). Moreover we have \\[\n\\g( a ) = \\g (b) = (0,0)\\,.\n\\] with \\(a = 2\\pi/3\\) and \\(b = 4\\pi/3\\). Note that \\[\nb-a = \\frac{4\\pi}{3} - \\frac{2\\pi}{3} = \\frac{2\\pi}{3}\n\\] which is not an integer multiple of the period \\(2\\pi\\). Therefore \\(\\g\\) is self-intersecting at \\((0,0)\\).\n\n\n\n\n\nLimaçon curve"
  },
  {
    "objectID": "sections/chap_4.html#curvature",
    "href": "sections/chap_4.html#curvature",
    "title": "4  Curvature and Torsion",
    "section": "4.1 Curvature",
    "text": "4.1 Curvature\nWe start with an informal discussion. Suppose \\({\\boldsymbol \\gamma}\\) is a straight line \\[\n{\\boldsymbol \\gamma}(t) = \\mathbf{a} + t \\mathbf{v}\n\\] with \\(\\mathbf{a}, \\mathbf{v} \\in \\mathbb{R}^3\\). The tangent vector to \\({\\boldsymbol \\gamma}\\) is constant \\[\n\\dot{\\boldsymbol \\gamma}(t) =  \\mathbf{v} \\,.\n\\] Whatever the definition of curvature will be, it has to hold that \\({\\boldsymbol \\gamma}\\) has zero curvature in this case. If we further derive the tangent vector, we obtain \\[\n\\ddot{\\boldsymbol \\gamma}(t) =  {\\boldsymbol 0}\\,.\n\\] Thus \\(\\ddot {\\boldsymbol \\gamma}\\) seems to be a good candidate for the definition of curvature of \\({\\boldsymbol \\gamma}\\) at the point \\({\\boldsymbol \\gamma}(t)\\).\nSuppose now that \\({\\boldsymbol \\gamma}\\) is a curve in \\(\\mathbb{R}^2\\) with unit speed. We have proven that in this case \\[\n\\dot {\\boldsymbol \\gamma}\\cdot \\ddot{\\boldsymbol \\gamma}= 0 \\,,\n\\] that is, the vector \\(\\ddot {\\boldsymbol \\gamma}\\) is orthogonal to the tangent \\(\\dot {\\boldsymbol \\gamma}\\) at all times. Now let \\(\\mathbf{n}(t)\\) be the unit vector orthogonal to \\(\\dot {\\boldsymbol \\gamma}(t)\\) at the point \\({\\boldsymbol \\gamma}(t)\\). The amount that the curve \\({\\boldsymbol \\gamma}\\) deviates from its tangent at \\({\\boldsymbol \\gamma}(t)\\) after time \\(t_0\\) is \\[\n( {\\boldsymbol \\gamma}(t + t_0) - {\\boldsymbol \\gamma}(t) ) \\cdot \\mathbf{n}(t) \\,,\n\\tag{4.1}\\] as seen in the figure below.\n\n\n\nAmount that \\({\\boldsymbol \\gamma}\\) deviates from tangent is \\(({\\boldsymbol \\gamma}(t+t_0)-{\\boldsymbol \\gamma}(t)) \\cdot \\mathbf{n}(t)\\)\n\n\nEquation (4.1) is what we take as measure of curvature. Since \\[\n\\dot {\\boldsymbol \\gamma}(t) \\cdot \\ddot {\\boldsymbol \\gamma}(t) = 0 \\quad \\mbox{ and } \\quad   \\dot {\\boldsymbol \\gamma}(t) \\cdot \\mathbf{n}(t)= 0 \\,,\n\\] we conclude that \\(\\ddot {\\boldsymbol \\gamma}(t)\\) is parallel to \\(\\mathbf{n}(t)\\). Since \\(\\mathbf{n}(t)\\) is a unit vector, there exists a scalar \\(\\kappa(t)\\) such that \\[\n\\ddot {\\boldsymbol \\gamma}(t)  = \\kappa(t) \\, \\mathbf{n}(t) \\,.\n\\] Note that, since \\(\\mathbf{n}\\) is unitary, we have \\[\n\\kappa(t) = \\left\\|  \\ddot {\\boldsymbol \\gamma}(t)  \\right\\|\n\\]\nNow, approximate \\({\\boldsymbol \\gamma}\\) at \\(t\\) with its second order Taylor polynomial: \\[\n{\\boldsymbol \\gamma}(t+t_0) = {\\boldsymbol \\gamma}(t) + \\dot{\\boldsymbol \\gamma}(t) t_0 + \\frac{\\ddot{\\boldsymbol \\gamma}(t)}{2} t_0^2 + o(t_0)\n\\] with the remainder \\(o(t_0)\\) is such that \\[\n\\lim_{t_0 \\to 0} \\ \\frac{o(t_0)}{t_0^2} = 0 \\,.\n\\] Therefore, forgetting about the remainder, \\[\n{\\boldsymbol \\gamma}(t+t_0) - {\\boldsymbol \\gamma}(t) \\approx \\dot{\\boldsymbol \\gamma}(t) t_0 + \\frac{\\ddot{\\boldsymbol \\gamma}(t)}{2} t_0^2 \\,.\n\\] Multiplying by \\(\\mathbf{n}(t)\\) we get \\[\n({\\boldsymbol \\gamma}(t+t_0) - {\\boldsymbol \\gamma}(t)) \\cdot \\mathbf{n}(t) \\approx \\dot{\\boldsymbol \\gamma}(t) \\cdot \\mathbf{n}(t) t_0 +\n\\frac{\\ddot{\\boldsymbol \\gamma}(t) \\cdot \\mathbf{n}(t) }{2} t_0^2\\,.\n\\] Recalling that \\[\n\\dot{\\boldsymbol \\gamma}(t) \\cdot \\mathbf{n}(t) = 0\\,, \\quad  \\ddot{\\boldsymbol \\gamma}(t) \\cdot \\mathbf{n}(t) = \\kappa(t) \\,,\n\\] we then obtain \\[\n({\\boldsymbol \\gamma}(t+t_0) - {\\boldsymbol \\gamma}(t)) \\cdot \\mathbf{n}(t) \\approx\n\\frac{1}{2} \\, \\kappa(t) \\, t_0^2\n\\]\n\nImportantThe amount that \\({\\boldsymbol \\gamma}\\) deviates from a straight line is proportional to \\[\n\\kappa(t) = \\left\\| \\ddot {\\boldsymbol \\gamma}(t) \\right\\|\\,.\n\\]\n\n\nWe take this as definition of curvature for a general unit speed curve in \\(\\mathbb{R}^n.\\)\n\nDefinition 1Let \\({\\boldsymbol \\gamma}\\ \\colon (a,b) \\to \\mathbb{R}^n\\) be a unit speed curve. The curvature of \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is \\[\n\\kappa^{\\boldsymbol \\gamma}(t) := \\left\\| \\ddot {\\boldsymbol \\gamma}(t) \\right\\| \\,.\n\\]\n\n\nNote that \\(\\kappa(t)\\) is a function of time. Therefore the curvature of \\({\\boldsymbol \\gamma}\\) can change from point to point.\nWe now define curvature for curves which are regular, but not necessarily unit speed.\n\nDefinition 2Let \\({\\boldsymbol \\gamma}\\ \\colon (a,b) \\to \\mathbb{R}^n\\) be a regular. The curvature of \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is \\[\n\\kappa^{\\boldsymbol \\gamma}(t) :=   \\left\\| \\ddot{\\widetilde{{\\boldsymbol \\gamma}}} (\\phi(t)) \\right\\| \\,, \\quad \\forall \\, t \\in (a,b)\\,,\n\\] where \\(\\widetilde{{\\boldsymbol \\gamma}}\\) is a unit speed reparametrization of \\({\\boldsymbol \\gamma}\\), with \\({\\boldsymbol \\gamma}= \\widetilde{{\\boldsymbol \\gamma}}\\circ \\phi\\).\n\n\n\nRemark 3\nThe above definition is well posed:\n\nSince \\({\\boldsymbol \\gamma}\\) is regular, there exist a unit speed reparametrization \\(\\widetilde{{\\boldsymbol \\gamma}}\\) of \\({\\boldsymbol \\gamma}\\).\nIf \\(\\hat{{\\boldsymbol \\gamma}}\\) is another unit speed reaprametrization of \\({\\boldsymbol \\gamma}\\), with \\({\\boldsymbol \\gamma}= \\hat{{\\boldsymbol \\gamma}} \\circ \\hat\\phi\\), then \\[\n\\kappa^{{\\boldsymbol \\gamma}} (t) =   \\left\\| \\ddot{\\hat{\\boldsymbol \\gamma}} (\\hat\\phi(t)) \\right\\| \\,,\n\\] showing that there is no ambiguity in the definition of \\(\\kappa^{\\boldsymbol \\gamma}\\).\n\n\nIndeed, since \\(\\widetilde{{\\boldsymbol \\gamma}}\\) and \\(\\hat{{\\boldsymbol \\gamma}}\\) are both reparametrizations of \\({\\boldsymbol \\gamma}\\), then \\[\n{\\boldsymbol \\gamma}(t) = \\widetilde{{\\boldsymbol \\gamma}}(  \\tilde{\\phi}(t)) \\,, \\quad\n{\\boldsymbol \\gamma}(t) = \\hat{{\\boldsymbol \\gamma}} (\\hat{\\phi}(t)  )\n\\] for some diffeomorphisms \\(\\tilde{\\phi}, \\hat{\\phi}\\). Hence \\[\n{\\widetilde{{\\boldsymbol \\gamma}}}(t) = \\hat{\\boldsymbol \\gamma}(\\phi(t))\\,, \\quad \\phi:= \\hat{\\phi} \\circ (\\tilde{\\phi})^{-1} \\,,\n\\tag{4.2}\\] where \\(\\phi\\) is a diffeomorphism, since it is composition of diffeomorphisms. Differentiating (4.2) we get \\[\n\\dot{\\widetilde{{\\boldsymbol \\gamma}}}(t) = \\dot{\\hat{{\\boldsymbol \\gamma}}}(\\phi(t)) \\dot\\phi(t) \\,.\n\\tag{4.3}\\] Taking the norms of the above, and recalling that \\(\\widetilde{{\\boldsymbol \\gamma}}\\) and \\(\\hat{\\boldsymbol \\gamma}\\) are unit speed, we get \\[\n|\\dot\\phi(t)| = 1 \\,, \\quad  \\forall \\, t \\,.\n\\tag{4.4}\\] Since \\(\\phi\\) is a diffeomorphism, we already know that \\(|\\dot\\phi| \\neq 0\\). As \\(\\dot\\phi\\) is continuous, this means that the sign of \\(\\dot\\phi\\) is constant. Thus (4.4) implies \\[\n\\dot\\phi(t) \\equiv 1 \\quad \\mbox{or} \\quad\n\\dot\\phi(t) \\equiv -1 \\,.\n\\] In both cases, we have \\[\n\\ddot \\phi\\equiv 0 \\,.\n\\] Differentiating (4.3) we then obtain \\[\\begin{align}\n\\ddot{\\widetilde{{\\boldsymbol \\gamma}}}(t) & = \\ddot{\\hat{{\\boldsymbol \\gamma}}}(\\phi(t)) \\dot\\phi^2(t) +\n\\dot{\\hat{{\\boldsymbol \\gamma}}}(\\phi(t)) \\ddot\\phi(t) \\\\\n& = \\ddot{\\hat{{\\boldsymbol \\gamma}}}(\\phi(t)) \\dot\\phi^2(t) \\,.\n\\end{align}\\] Taking the norms and using again that \\(|\\dot\\phi| \\equiv 1\\), we get that \\[\n\\left\\|   \\ddot{\\widetilde{{\\boldsymbol \\gamma}}}(t) \\right\\| = \\left\\|  \\ddot{\\hat{{\\boldsymbol \\gamma}}}(\\phi(t)) \\right\\| \\,.\n\\] Recalling that \\(\\phi = \\hat\\phi\\circ (\\tilde{\\phi})^{-1}\\) we get \\[\n\\left\\|   \\ddot{\\widetilde{{\\boldsymbol \\gamma}}}( \\tilde{\\phi}(t)) \\right\\| = \\left\\|  \\ddot{\\hat{{\\boldsymbol \\gamma}}}(\\hat\\phi(t)) \\right\\| \\,, \\quad \\forall \\, t \\in (a,b) \\,.\n\\] Therefore \\[\n\\kappa^{\\boldsymbol \\gamma}(t) =  \\left\\|   \\ddot{\\widetilde{{\\boldsymbol \\gamma}}}( \\tilde{\\phi}(t)) \\right\\| = \\left\\|  \\ddot{\\hat{{\\boldsymbol \\gamma}}}(\\hat\\phi(t)) \\right\\| \\,.\n\\]\n\n\n\n\nRemark 4: Methods for computing curvatureIn summary, the curvature of a regular curve \\[\n{\\boldsymbol \\gamma}\\ \\colon (a,b) \\to \\mathbb{R}^n\n\\] is defined via unit speed reparametrizations of \\({\\boldsymbol \\gamma}\\). To compute \\(\\kappa\\) we do the following:\n\nWe find a unit speed reparametrization \\(\\widetilde{{\\boldsymbol \\gamma}}\\) of the regular curve \\({\\boldsymbol \\gamma}\\)\nThis can be done by computing \\(s\\) the arc-length of \\({\\boldsymbol \\gamma}\\), and then defining \\[\n\\widetilde{{\\boldsymbol \\gamma}}:= {\\boldsymbol \\gamma}\\circ \\psi \\,, \\quad \\psi:=s^{-1}\n\\]\nThen we compute \\[\n\\kappa^{\\widetilde{{\\boldsymbol \\gamma}}}(t) = \\left\\| \\ddot{\\widetilde{{\\boldsymbol \\gamma}}} \\right\\|(t)\n\\]\nWe obtain the curvature of \\({\\boldsymbol \\gamma}\\) by \\[\n\\kappa^{\\boldsymbol \\gamma}(t)= \\kappa^{\\widetilde{{\\boldsymbol \\gamma}}} (t)\n\\]\n\nWhen \\({\\boldsymbol \\gamma}\\) is regular and has values in \\(\\mathbb{R}^3\\), there is a way to compute \\(\\kappa\\) without reparametrizing. To do this, we will need the notion of cross product, or vector product. We will see this in the following sections.\n\n\n\n\n\nProcedure for computing curvature \\(\\kappa\\)\n\n\nWe conclude with an example where we compute \\(\\kappa\\) using reparametrizations.\n\nExample 5Consider the circle of radius \\(R&gt;0\\): \\[\n{\\boldsymbol \\gamma}(t) = (R\\cos(t),R\\sin(t)) \\,, \\quad t \\in [0,2\\pi] \\,.\n\\] To compute the curvature of \\({\\boldsymbol \\gamma}\\) we need to find a unit speed reparametrization. We have shown that: \\[\n{\\boldsymbol \\gamma}\\, \\mbox{ regular } \\,\\,\\, \\implies \\,\\,\\, \\phi= s^{-1} \\, \\mbox{ unit speed reparametrization}\n\\] where \\(s\\) is the arc length of \\({\\boldsymbol \\gamma}\\): \\[\ns(t):= \\int_{t_0}^t \\left\\| \\dot {\\boldsymbol \\gamma}(\\tau) \\right\\| \\, d\\tau  \\,.\n\\] In our case \\[\n\\dot {\\boldsymbol \\gamma}(t) = (-R\\sin(t), R\\cos(t))  \\quad \\implies \\quad\n\\left\\| \\dot {\\boldsymbol \\gamma}(t) \\right\\| = R  \n\\] and so \\({\\boldsymbol \\gamma}\\) is regular. The arc length starting at \\(t_0 = 0\\) is \\[\ns(t) = \\int_{0}^t R d \\tau = t R \\,.\n\\] The inverse of \\(s\\) is \\[\n\\phi(t) := s^{-1} (t) = \\frac{t}{R} \\,.\n\\] Therefore a unit speed reparametrization of \\({\\boldsymbol \\gamma}\\) is \\[\n\\widetilde{{\\boldsymbol \\gamma}}:={\\boldsymbol \\gamma}\\circ \\phi\n\\] which reads \\[\n\\widetilde{{\\boldsymbol \\gamma}}(t) :=  \\left( R \\cos \\left( \\frac{t}{R} \\right) , R \\sin \\left( \\frac{t}{R} \\right)\\right) \\,.\n\\] We have \\[\\begin{align}\n\\dot{\\widetilde{{\\boldsymbol \\gamma}}} (t) & =  \\left( - \\sin \\left( \\frac{t}{R} \\right) ,  \\cos \\left( \\frac{t}{R} \\right)\\right) \\\\\n\\ddot{\\widetilde{{\\boldsymbol \\gamma}}} (t) & =  \\left( -\\frac{1}{R} \\cos \\left( \\frac{t}{R} \\right) ,  - \\frac{1}{R} \\sin \\left( \\frac{t}{R} \\right)\\right)\n\\end{align}\\] Therefore the curvature of \\({\\boldsymbol \\gamma}\\) is \\[\n\\kappa(t) = \\left\\|  \\ddot{\\widetilde{{\\boldsymbol \\gamma}}} (t)  \\right\\| = \\frac{1}{R} \\,.\n\\] In this case \\(\\kappa(t)\\) is constant. The curvature also tells us that the smaller the circle, the higher the curvature. For a large circle, like the Earth, the curvature is barely noticeable."
  },
  {
    "objectID": "sections/chap_4.html#vector-product-in-mathbbr3",
    "href": "sections/chap_4.html#vector-product-in-mathbbr3",
    "title": "4  Curvature and Torsion",
    "section": "4.2 Vector product in \\(\\mathbb{R}^3\\)",
    "text": "4.2 Vector product in \\(\\mathbb{R}^3\\)\nThe discussion in this section follows (Carmo 2017). We start by defining orientation for a vector space.\n\nDefinition 6: Same orientationConsider two ordered basis of \\(\\mathbb{R}^3\\) \\[\nB = (\\mathbf{b}_1,\\mathbf{b}_2,\\mathbf{b}_3) \\,, \\quad \\tilde{B} = (\\widetilde{\\mathbf{b}}_1,\\widetilde{\\mathbf{b}}_2,\\widetilde{\\mathbf{b}}_3) \\,.\n\\] We say that \\(B\\) and \\(\\widetilde{B}\\) have the same orientation if the matrix of change of basis has positive determinant.\n\n\nWhen two basis \\(B\\) and \\(\\widetilde{B}\\) have the same orientation, we write \\[\n\\mathbf{b}\\sim \\widetilde{\\mathbf{b}} \\,.\n\\] The above is clearly an equivalence relation on the set of ordered basis. Therefore the set of ordered basis of \\(\\mathbb{R}^3\\) can be decomposed into equivalence classes. Since the determinant of the matrix of change of basis can only be positive or negative, there are only two equivalence classes.\n\nDefinition 7: OrientationThe two equivalence classes determined by \\(\\sim\\) on the set of ordered basis are called orientations.\n\n\n\nDefinition 8: Positive orientation\nConsider the standard basis of \\(\\mathbb{R}^3\\) \\[\nE = (\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_3)\n\\] where we set \\[\n\\mathbf{e}_1 = (1,0,0)\\,, \\quad \\mathbf{e}_2 = (0,1,0) \\,, \\quad \\mathbf{e}_3 = (0,0,1) \\,.\n\\] Then:\n\nThe orientation corresponding to \\(E\\) is called positive orientation of \\(\\mathbb{R}^3\\).\nThe orientation corresponding to the other equivalence class is called negative orientation of \\(\\mathbb{R}^3\\).\n\nFor a basis \\(B\\) of \\(\\mathbb{R}^3\\) we say that:\n\n\\(B\\) is a positive basis if it belongs to the class of \\(e\\).\n\\(B\\) is a negative basis if it does not belong to the class of \\(e\\).\n\n\n\n\nExample 9Since we are dealing with ordered basis, the order in which vectors appear is fundamental. For example, we defined the equivalence class of \\[\nE = (\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_3) \\,,\n\\] to be the positive orientation of \\(\\mathbb{R}^3\\). In particular \\(e\\) is a positive basis.\nConsider instead \\[\n\\widetilde{E} = (\\mathbf{e}_2,\\mathbf{e}_1,\\mathbf{e}_3) \\,.\n\\] The matrix of change of variables between \\(\\widetilde{E}\\) and \\(E\\) is \\[\n(\\mathbf{e}_2 | \\mathbf{e}_1 | \\mathbf{e}_3 ) = \\left(\n\\begin{array}{ccc}\n0 & 1 & 0 \\\\\n1 & 0 & 0 \\\\\n0 & 0 & 1 \\\\\n\\end{array}\n\\right)\n\\] and the latter has negative determinant. Thus \\(\\widetilde{E}\\) does not belong to the class of \\(E\\), and is therefore a negative basis.\n\n\nWe are now ready to define the vector product in \\(\\mathbb{R}^3\\).\n\nDefinition 10: Vector product in \\(\\mathbb{R}^3\\)Let \\(\\mathbf{u},\\mathbf{v}\\in \\mathbb{R}^3\\). The vector product of \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\) is the unique vector \\[\n\\mathbf{u}\\times \\mathbf{v}\\in \\mathbb{R}^3\n\\] which satisfies the property: \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\cdot \\mathbf{w}=\n\\left|\n\\begin{array}{ccc}\nu_1 & u_2 & u_3 \\\\\nv_1 & v_2 & v_3 \\\\\nw_1 & w_2 & w_3 \\\\\n\\end{array}\n\\right| \\,, \\quad \\forall \\, \\mathbf{w}\\in \\mathbb{R}^3 \\,.\n\\tag{4.5}\\] Here \\(|a_{ij}|\\) denotes the determinant of the matrix \\((a_{ij})\\), and \\[\n\\mathbf{u}= \\sum_{i=1}^3 u_i \\mathbf{e}_i \\,, \\quad\n\\mathbf{v}= \\sum_{i=1}^3 v_i \\mathbf{e}_i \\,, \\quad\n\\mathbf{w}= \\sum_{i=1}^3 w_i \\mathbf{e}_i \\,,\n\\] with \\((\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_3)\\) standard basis of \\(\\mathbb{R}^3\\).\n\n\nThe following proposition gives an explicit formula for computing \\(\\mathbf{u}\\times \\mathbf{v}\\).\n\nProposition 11Let \\(\\mathbf{u},\\mathbf{v}\\in \\mathbb{R}^3\\). Then \\[\n\\mathbf{u}\\times \\mathbf{v}=\n\\left|\n\\begin{array}{cc}\nu_2 & u_3  \\\\\nv_2 & v_3\n\\end{array}\n\\right| \\mathbf{e}_1 -\n\\left|\n\\begin{array}{cc}\nu_1 & u_3  \\\\\nv_1 & v_3\n\\end{array}\n\\right| \\mathbf{e}_2 +\n\\left|\n\\begin{array}{cc}\nu_1 & u_2  \\\\\nv_1 & v_2\n\\end{array}\n\\right| \\mathbf{e}_3  \\,.\n\\tag{4.6}\\]\n\n\n\nProofDenote by \\((\\mathbf{u}\\times \\mathbf{v})_i\\) the \\(i\\)-th component of \\(\\mathbf{u}\\times \\mathbf{v}\\) with respect to the standard basis, that is, \\[\n\\mathbf{u}\\times \\mathbf{v}= \\sum_{i=1}^3  (\\mathbf{u}\\times \\mathbf{v})_i \\, \\mathbf{e}_i \\,.\n\\] We can use (4.5) with \\(\\mathbf{w}= \\mathbf{e}_1\\) to obtain \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\cdot \\mathbf{e}_1  =\n\\left|\n\\begin{array}{ccc}\nu_1 & u_2 & u_3 \\\\\nv_1 & v_2 & v_3 \\\\\n1  & 0   &   0 \\\\\n\\end{array}\n\\right| =\n\\left|\n\\begin{array}{cc}\nu_2 & u_3  \\\\\nv_2 & v_3\n\\end{array}\n\\right|\n\\] where we used the Laplace expansion for computing the determinant of the \\(3 \\times 3\\) matrix. As the standard basis is orthonormal, by bilinearity of the scalar product we get \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\cdot \\mathbf{e}_1 = \\sum_{i=1}^3  (\\mathbf{u}\\times \\mathbf{v})_i \\, \\mathbf{e}_i \\cdot \\mathbf{e}_1 = (\\mathbf{u}\\times \\mathbf{v})_i \\,.\n\\] Therefore we have shown \\[\n(\\mathbf{u}\\times \\mathbf{v})_1 = \\left|\n\\begin{array}{cc}\nu_2 & u_3  \\\\\nv_2 & v_3\n\\end{array}\n\\right| \\,.\n\\] Similarly we obtain \\[\n(\\mathbf{u}\\times \\mathbf{v})_2  = \\left|\n\\begin{array}{ccc}\nu_1 & u_2 & u_3 \\\\\nv_1 & v_2 & v_3 \\\\\n0  & 1   &   0 \\\\\n\\end{array}\n\\right| = -\n\\left|\n\\begin{array}{cc}\nu_1 & u_3  \\\\\nv_1 & v_3\n\\end{array}\n\\right|\n\\] and \\[\n(\\mathbf{u}\\times \\mathbf{v})_3  = \\left|\n\\begin{array}{ccc}\nu_1 & u_2 & u_3 \\\\\nv_1 & v_2 & v_3 \\\\\n0  & 0   &   1 \\\\\n\\end{array}\n\\right| =\n\\left|\n\\begin{array}{cc}\nu_1 & u_2  \\\\\nv_1 & v_2\n\\end{array}\n\\right| \\,,\n\\] from which we conclude.\n\n\n\nProposition 12\nThe vector product in \\(\\mathbb{R}^3\\) satisfies the following properties: For all \\(\\mathbf{u}, \\mathbf{v}\\in \\mathbb{R}^3\\)\n\n\\(\\mathbf{u}\\times \\mathbf{v}= - \\mathbf{v}\\times \\mathbf{u}\\)\n\\(\\mathbf{u}\\times \\mathbf{v}= {\\boldsymbol 0}\\) if and only if \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\) are linearly dependent\n\\((\\mathbf{u}\\times \\mathbf{v}) \\cdot \\mathbf{u}= 0\\), \\((\\mathbf{u}\\times \\mathbf{v}) \\cdot \\mathbf{v}= 0\\)\nFor all \\(\\mathbf{w}\\in \\mathbb{R}^3\\), \\(a,b \\in \\mathbb{R}\\) \\[\n(a\\mathbf{u}+ b\\mathbf{w}) \\times \\mathbf{v}= a \\mathbf{u}\\times \\mathbf{v}+ b\\mathbf{w}\\times \\mathbf{w}\n\\]\n\n\n\nThe proof, which is based on the properties of determinants, is omitted.\n\nRemark 13: Geometric interpretation of vector product\nLet \\(\\mathbf{u}, \\mathbf{v}\\in \\mathbb{R}^3\\) be linearly independent. We make some observations:\n\nProperty 3 in Proposition 12 says that \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\cdot \\mathbf{u}= 0 \\,, \\quad  (\\mathbf{u}\\times \\mathbf{v}) \\cdot \\mathbf{v}= 0 \\,.\n\\] Therefore \\(\\mathbf{u}\\times \\mathbf{v}\\) is orthogonal to both \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\).\nIn particular \\(\\mathbf{u}\\times \\mathbf{v}\\) is orthogonal to the plane generated by \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\).\nSince \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\) are linearly independent, Property 2 in Proposition 12 says that \\[\n\\mathbf{u}\\times \\mathbf{v}\\neq {\\boldsymbol 0}\n\\]\nTherefore we have \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\cdot (\\mathbf{u}\\times \\mathbf{v}) = \\left\\|  \\mathbf{u}\\times \\mathbf{v} \\right\\|^2 &gt; 0\n\\]\nOn the other hand, using the definition of \\(\\mathbf{u}\\times \\mathbf{v}\\) with \\(\\mathbf{w}= \\mathbf{v}\\times \\mathbf{w}\\) yields \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\cdot (\\mathbf{u}\\times \\mathbf{v}) =\n\\left|\n\\begin{array}{ccc}\nu_1 & u_2 & u_3 \\\\\nv_1 & v_2 & v_3 \\\\\n(\\mathbf{u}\\times \\mathbf{v})_1 & (\\mathbf{u}\\times \\mathbf{v})_2 & (\\mathbf{u}\\times \\mathbf{v})_3 \\\\\n\\end{array}\n\\right|\n\\]\nTherefore the determinant of the matrix \\[\n(\\mathbf{u}| \\mathbf{v}| \\mathbf{u}\\times \\mathbf{v})\n\\] is positive. This shows that \\[\n(\\mathbf{u}, \\mathbf{v}, \\mathbf{u}\\times \\mathbf{v})\n\\] is a positive basis of \\(\\mathbb{R}^3\\).\nFor all \\(\\mathbf{u},\\mathbf{v},\\mathbf{x},\\mathbf{y}\\in \\mathbb{R}^3\\) it holds \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\cdot (\\mathbf{x}\\times \\mathbf{y}) =\n\\left|\n\\begin{array}{cc}\n\\mathbf{u}\\cdot \\mathbf{x}& \\mathbf{v}\\cdot \\mathbf{x}\\\\\n\\mathbf{u}\\cdot \\mathbf{y}& \\mathbf{v}\\cdot \\mathbf{y}\n\\end{array}\n\\right| \\,.\n\\tag{4.7}\\] Indeed, one can check that the above formula holds for the standard vectors \\(\\mathbf{e}_i\\), and thus the general formula follows by linearity.\nUsing (4.7) we get \\[\\begin{align}\n\\left\\| \\mathbf{u}\\times \\mathbf{v} \\right\\|^2 & = (\\mathbf{u}\\times \\mathbf{v}) \\cdot (\\mathbf{u}\\times \\mathbf{v}) =\n\\left|\n\\begin{array}{cc}\n\\mathbf{u}\\cdot \\mathbf{u}& \\mathbf{v}\\cdot \\mathbf{u}\\\\\n\\mathbf{u}\\cdot \\mathbf{v}& \\mathbf{v}\\cdot \\mathbf{v}\n\\end{array}\n\\right|   \\\\\n& = \\left\\| \\mathbf{u} \\right\\|^2 \\left\\| \\mathbf{v} \\right\\|^2 - |\\mathbf{u}\\cdot \\mathbf{v}|^2 \\\\\n& = \\left\\| \\mathbf{u} \\right\\|^2 \\left\\| \\mathbf{v} \\right\\|^2 - \\left\\| \\mathbf{u} \\right\\|^2 \\left\\| \\mathbf{v} \\right\\|^2 \\cos^2(\\theta) \\\\\n& = \\left\\| \\mathbf{u} \\right\\|^2\\left\\| \\mathbf{v} \\right\\|^2 (1-\\cos^2(\\theta)) \\\\\n& = \\left\\| \\mathbf{u} \\right\\|^2\\left\\| \\mathbf{v} \\right\\|^2 \\sin^2(\\theta) \\\\\n& = A^2  \n\\end{align}\\] where \\(A\\) is the area of the parallelogram with sides \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\).\n\n\n\n\n\n\nFor \\(\\mathbf{u},\\mathbf{v}\\) linearly independent, \\(\\mathbf{u}\\times \\mathbf{v}\\) is orthogonal to the plane generated by \\(\\mathbf{u},\\mathbf{v}\\). Moreover \\(|\\mathbf{u}\\times \\mathbf{v}|\\) is the area of the parallelogram with sides \\(\\mathbf{u},\\mathbf{v}\\), and \\((\\mathbf{u},\\mathbf{v},\\mathbf{u}\\times \\mathbf{v})\\) is a positive basis of \\(\\mathbb{R}^3\\)\n\n\nLet us summarize the above remark.\n\nRemark 14: Summary: Properties of \\(\\mathbf{u}\\times \\mathbf{v}\\)\nLet \\(\\mathbf{u},\\mathbf{v}\\in \\mathbb{R}^3\\) be linearly independent. Then\n\n\\(\\mathbf{u}\\times \\mathbf{v}\\) is orthogonal to the plane spanned by \\(\\mathbf{u},\\mathbf{v}\\)\n\\(\\left\\| \\mathbf{u}\\times \\mathbf{v} \\right\\|\\) is equal to the area of the parallelogram with sides \\(\\mathbf{u},\\mathbf{v}\\)\n\\(\\mathbf{u}\\times \\mathbf{v}\\) is such that \\[\n(\\mathbf{u},\\mathbf{v},\\mathbf{u}\\times \\mathbf{v})\n\\] is a positive basis of \\(\\mathbb{R}^3\\).\n\n\n\nWe conclude with noting that the cross product is not associative, and with a useful proposition for differentiating the cross product of curves in \\(\\mathbb{R}^3\\).\n\nProposition 15The vector product is not associative. In particular, for all \\(\\mathbf{u}, \\mathbf{v}, \\mathbf{w}\\in \\mathbb{R}^3\\) it holds: \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\times \\mathbf{w}= ( \\mathbf{u}\\cdot \\mathbf{w}) \\mathbf{v}- ( \\mathbf{v}\\cdot \\mathbf{w}) \\mathbf{u}\\,.\n\\tag{4.8}\\]\n\n\nThe proof is omitted. It follows by observing that both sides of (4.8) are linear in \\(\\mathbf{u}, \\mathbf{v}, \\mathbf{w}\\). Therefore it is sufficient to verify (4.8) for the standard basis vectors \\(\\mathbf{e}_i\\). This is left as an exercise.\n\nProposition 16Suppose \\({\\boldsymbol \\gamma},{\\boldsymbol \\eta}\\ \\colon (a,b) \\to \\mathbb{R}^3\\) are parametrized curves. Then the curve \\[\n{\\boldsymbol \\gamma}\\times {\\boldsymbol \\eta}\\ \\colon (a,b) \\to \\mathbb{R}^3\n\\] is smooth, and \\[\n\\frac{d}{dt} ( {\\boldsymbol \\gamma}\\times {\\boldsymbol \\eta}) = \\dot {\\boldsymbol \\gamma}\\times {\\boldsymbol \\eta}+ {\\boldsymbol \\gamma}\\times \\dot {\\boldsymbol \\eta}\\,.\n\\tag{4.9}\\]\n\n\nThe proof is omitted. It follows immediately from formula (4.6)."
  },
  {
    "objectID": "sections/chap_4.html#curvature-formula-in-mathbbr3",
    "href": "sections/chap_4.html#curvature-formula-in-mathbbr3",
    "title": "4  Curvature and Torsion",
    "section": "4.3 Curvature formula in \\(\\mathbb{R}^3\\)",
    "text": "4.3 Curvature formula in \\(\\mathbb{R}^3\\)\nGiven a unit speed curve \\[\n{\\boldsymbol \\gamma}\\ \\colon (a,b) \\to \\mathbb{R}^n\n\\] we defined its curvature as \\[\n\\kappa(t) = \\left\\|  \\ddot{{\\boldsymbol \\gamma}}(t)  \\right\\| \\,.\n\\] If \\({\\boldsymbol \\gamma}\\) is not unit speed then the curvature is not defined. However, when \\({\\boldsymbol \\gamma}\\) is regular, then we can find a unit-speed reparametrization \\(\\widetilde{{\\boldsymbol \\gamma}}\\) of \\({\\boldsymbol \\gamma}\\), and compute \\(\\kappa\\) as \\[\n\\kappa(t) = \\left\\|  \\ddot{\\widetilde{{\\boldsymbol \\gamma}}}(t)  \\right\\| \\,.\n\\] If \\({\\boldsymbol \\gamma}\\) is a regular curve in \\(\\mathbb{R}^3\\), there is a way to compute \\(\\kappa\\) without passing through \\(\\widetilde{{\\boldsymbol \\gamma}}\\). The formula for computing \\(\\kappa\\) is as follows.\n\nProposition 17Let \\({\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3\\) be a regular curve. Then the curvature \\(\\kappa(t)\\) of \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is given by \\[\n\\kappa(t) = \\frac{ \\left\\| \\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\| }{ \\left\\| \\dot {\\boldsymbol \\gamma} \\right\\|^3 } \\,.\n\\tag{4.10}\\]\n\n\nWe delay the proof of the above Proposition, as this will get easier when the Frenet frame is introduced. For a proof which does not make use of the Frenet frame, see the proof of Proposition 2.1.2 in (Pressley 2010).\nFor now we use (4.10) the above proposition to compute the curvature on specific curves.\n\nExample 18Consider the straight line \\[\n{\\boldsymbol \\gamma}(t) = \\mathbf{a} + t \\mathbf{v}\n\\] for some \\(\\mathbf{a}, \\mathbf{v} \\in \\mathbb{R}^3\\) fixed, with \\(\\mathbf{v} \\neq {\\boldsymbol 0}\\). Then \\[\n\\dot {\\boldsymbol \\gamma}(t) = \\mathbf{v} \\,, \\quad \\ddot {\\boldsymbol \\gamma}(t) = {\\boldsymbol 0}\\,.\n\\] Therefore \\[\n\\left\\| \\dot {\\boldsymbol \\gamma}(t) \\right\\| = \\left\\| \\mathbf{v} \\right\\| \\neq 0\n\\] showing that \\({\\boldsymbol \\gamma}\\) is regular. We have \\[\n\\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma}= \\mathbf{v} \\times {\\boldsymbol 0}= {\\boldsymbol 0}\\,.\n\\] Therefore the curvature is \\[\n\\kappa = \\frac{ \\left\\|  \\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\| }{ \\left\\| \\dot{\\boldsymbol \\gamma} \\right\\|^3 } = 0 \\,,\n\\] as expected.\n\n\n\nExample 19\nConsider the Helix of radius \\(R&gt;0\\) and rise \\(H&gt;0\\) \\[\n{\\boldsymbol \\gamma}(t) = ( R\\cos(t) , R\\sin(t) , Ht) \\,, \\quad t \\in \\mathbb{R}\\,.\n\\] Then \\[\\begin{align}\n\\dot{\\boldsymbol \\gamma}(t) & = ( -R\\sin(t) , R\\cos(t) , H)  \\\\\n\\ddot{\\boldsymbol \\gamma}(t) & = ( -R\\cos(t) , -R\\sin(t) , 0)\n\\end{align}\\] From this we deduce that \\[\n\\left\\| \\dot{\\boldsymbol \\gamma}(t) \\right\\|  = \\sqrt{R^2 + H^2}\\,,\n\\] showing that \\({\\boldsymbol \\gamma}\\) is regular. Finally \\[\\begin{align}\n\\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma}& =\n\\left|\n\\begin{array}{cc}\n{\\dot{\\boldsymbol \\gamma}}_2 & {\\dot{\\boldsymbol \\gamma}}_3  \\\\\n{\\ddot{\\boldsymbol \\gamma}}_2 & {\\ddot{\\boldsymbol \\gamma}}_3\n\\end{array}\n\\right| \\mathbf{e}_1 -\n\\left|\n\\begin{array}{cc}\n{\\dot{\\boldsymbol \\gamma}}_1 & {\\dot{\\boldsymbol \\gamma}}_3  \\\\\n{\\ddot{\\boldsymbol \\gamma}}_1 & {\\ddot{\\boldsymbol \\gamma}}_3\n\\end{array}\n\\right| \\mathbf{e}_2 +\n\\left|\n\\begin{array}{cc}\n{\\dot{\\boldsymbol \\gamma}}_1 & {\\dot{\\boldsymbol \\gamma}}_2  \\\\\n{\\ddot{\\boldsymbol \\gamma}}_1 & {\\ddot{\\boldsymbol \\gamma}}_2\n\\end{array}\n\\right| \\mathbf{e}_3 \\\\\n& =\n\\left|\n\\begin{array}{cc}\nR\\cos(t) & H \\\\\n-R\\sin(t) & 0\n\\end{array}\n\\right| \\mathbf{e}_1 -\n\\left|\n\\begin{array}{cc}\n-R\\sin(t) & H \\\\\n-R\\cos(t) & 0\n\\end{array}\n\\right| \\mathbf{e}_2 +\n\\left|\n\\begin{array}{cc}\n-R\\sin(t) & R\\cos(t) \\\\\n-R\\cos(t) & -R\\sin(t)  \n\\end{array}\n\\right| \\mathbf{e}_3 \\\\\n& =\n\\left(   \nRH\\sin(t),    \n-RH\\cos(t),\nR^2\\cos^2(t) + R^2\\sin^2(t)\n\\right) \\\\\n& =\n\\left(   \nRH\\sin(t),    \n-RH\\cos(t),\nR^2\n\\right)\n\\end{align}\\] and therefore \\[\n\\left\\|  \\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\| =  R\\sqrt{R^2 + H^2   } \\,.\n\\] By the general formula we have \\[\n\\kappa = \\frac{ \\left\\|  \\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\| }{ \\left\\| \\dot{\\boldsymbol \\gamma} \\right\\|^3 } =\n\\frac{ R (R^2 + H^2)^{\\frac12} }{  (R^2 + H^2)^{\\frac32}    } =\n\\frac{ R }{  R^2 + H^2   }\n\\]\nWe notice the following:\n\nIf \\(H=0\\) then the Helix is just a circle of radius \\(R\\). In this case the curvature is \\[\n\\kappa  = \\frac{1}{R}\n\\] which agrees with the curvature computed for the circle of radius \\(R\\).\nIf \\(R=0\\) then the Helix is just parametrizing the \\(z\\)-axis. In this case the curvature is \\[\n\\kappa  = 0 \\,,\n\\] which agrees with the curvature of a straight line."
  },
  {
    "objectID": "sections/chap_4.html#signed-curvature-of-plane-curves",
    "href": "sections/chap_4.html#signed-curvature-of-plane-curves",
    "title": "4  Curvature and Torsion",
    "section": "4.4 Signed curvature of plane curves",
    "text": "4.4 Signed curvature of plane curves\nIn this section we assume to have plane curves, that is, curves with values in \\(\\mathbb{R}^2\\). In this case we can give a geometric interpretation for the sign of the curvature. This cannot be done in higher dimension.\n\nDefinition 20Let \\({\\boldsymbol \\gamma}\\ \\colon (a,b) \\to \\mathbb{R}^2\\) be unit speed. We define the signed unit normal to \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) as the unit vector \\(\\mathbf{n}(t)\\) obtained by rotating \\(\\dot {\\boldsymbol \\gamma}(t)\\) anti-clockwise by an angle of \\(\\pi/2\\).\n\n\n\nDefinition 21Let \\({\\boldsymbol \\gamma}\\ \\colon (a,b) \\to \\mathbb{R}^2\\) be unit speed. The signed curvature of \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is the scalar \\(\\kappa_s(t)\\) such that \\[\n\\ddot {\\boldsymbol \\gamma}(t) = k_s(t) \\mathbf{n}(t)\n\\]\n\n\n\nRemark 22Notice that since \\(\\mathbf{n}\\) is a unit vector and \\({\\boldsymbol \\gamma}\\) is unit speed, then \\[\n|\\kappa_s(t)| = \\left\\| \\ddot {\\boldsymbol \\gamma}(t) \\right\\| = \\kappa(t) \\,.\n\\] Thus the signed curvature is related to the curvature by \\[\n\\kappa_s(t) = \\pm \\kappa(t) \\,.\n\\]\n\n\n\nRemark 23It can be shown that the signed curvature is the rate at which the tangent vector \\(\\dot {\\boldsymbol \\gamma}\\) of the curve \\({\\boldsymbol \\gamma}\\) rotates. The signed curvature is:\n\npositive if \\(\\dot {\\boldsymbol \\gamma}\\) is rotating anti-clockwise\nnegative if \\(\\dot {\\boldsymbol \\gamma}\\) is rotating clockwise\n\nIn other words,\n\n\\(k_s &gt; 0\\) means the curve is turning left,\n\\(k_s &lt; 0\\) means the curve is turning right.\n\nA rigorous justification of the above statement is found in Proposition 2.2.3 in (Pressley 2010).\n\n\nFor curves which are not unit speed, we define the signed curvature as the signed curvature of the unit speed reparametrization.\n\nDefinition 24Let \\({\\boldsymbol \\gamma}\\ \\colon (a,b) \\to \\mathbb{R}^2\\) be regular and let \\(\\widetilde{{\\boldsymbol \\gamma}}\\) be a unit speed reparametrization of \\({\\boldsymbol \\gamma}\\). The signed curvature of \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is the scalar \\(\\kappa_s(t)\\) such that \\[\n\\ddot{\\widetilde{{\\boldsymbol \\gamma}}}(t) = k_s(t) \\mathbf{n}(t) \\,,\n\\] where \\(\\mathbf{n}(t)\\) is the unit vector obtained by rotating \\(\\dot{\\widetilde{{\\boldsymbol \\gamma}}}(t)\\) anti-clockwise by an angle \\(\\pi/2\\).\n\n\nThe signed curvature completely characterizes plane curves, in the sense of the following theorem.\n\nTheorem 25\nLet \\(\\phi\\ \\colon \\mathbb{R}\\to \\mathbb{R}\\) be smooth. Then:\n\nThere exists a parametrized curve \\({\\boldsymbol \\gamma}\\ \\colon \\mathbb{R}\\to \\mathbb{R}^2\\) such that its signed curvature \\(\\kappa_s\\) satisfies \\[\n\\kappa_s(t) = \\phi(t) \\,, \\quad \\forall \\, t \\in \\mathbb{R}\\,.\n\\]\nSuppose that \\(\\widetilde{{\\boldsymbol \\gamma}}\\ \\colon \\mathbb{R}\\to \\mathbb{R}^2\\) is any curve such that its signed curvature \\(\\tilde{\\kappa}_s\\) satisfies \\[\n\\tilde{\\kappa}_s(t) = \\phi(t) \\,, \\quad \\forall \\, t \\in \\mathbb{R}\\,.\n\\] Then \\[\n\\widetilde{{\\boldsymbol \\gamma}}= {\\boldsymbol \\gamma}\n\\] up to rotations and translations.\n\n\n\nWe do not prove the above theorem. For a proof, see Theorem 2.2.6 in (Pressley 2010)."
  },
  {
    "objectID": "sections/chap_4.html#space-curves",
    "href": "sections/chap_4.html#space-curves",
    "title": "4  Curvature and Torsion",
    "section": "4.5 Space curves",
    "text": "4.5 Space curves\nIn this section we deal with space curves, that is, curves with values in \\(\\mathbb{R}^3\\). There are several issues compare to the plane case:\n\nA 3D counterpart of the signed curvature does not exist, since there is no notion of turning left or turning right.\nWe have seen in the previous section that the signed curvature completely characterizes plane curves. In 3D however curvature is not enough to characterize curves: there exist \\({\\boldsymbol \\gamma}\\) and \\({\\boldsymbol \\eta}\\) space curves such that \\[\n\\kappa^{{\\boldsymbol \\gamma}} = \\kappa^{{\\boldsymbol \\eta}} \\,, \\quad  {\\boldsymbol \\gamma}\\neq {\\boldsymbol \\eta}\\,,\n\\] that is, \\({\\boldsymbol \\gamma}\\) and \\({\\boldsymbol \\eta}\\) have same curvature but are different curves.\n\n\nExample 26Let \\({\\boldsymbol \\gamma}\\) be a circle of radius \\(R&gt;0\\) \\[\n{\\boldsymbol \\gamma}(t) = (R\\cos(t),R\\sin(t),0) \\,,\n\\] and \\({\\boldsymbol \\eta}\\) be a helix of radius \\(S&gt;0\\) and rise \\(H&gt;0\\) \\[\n{\\boldsymbol \\eta}(t) = (S\\cos(t),S\\sin(t),Ht) \\,.\n\\] We have computed that \\[\n\\kappa^{\\boldsymbol \\gamma}= \\frac{1}{R}\\,, \\quad\n\\kappa^{\\boldsymbol \\eta}= \\frac{S}{S^2 + H^2} \\,.\n\\] If we now choose \\(R=2\\) and we impose that \\(\\kappa^{\\boldsymbol \\gamma}= \\kappa^{\\boldsymbol \\eta}\\) we get \\[\n\\frac1R = \\frac{S}{S^2 + H^2} \\quad \\implies \\quad  H^2 = 2S - S^2\n\\] Therefore choosing \\(S=1\\) and \\(H=1\\) yields \\[\n\\kappa^{\\boldsymbol \\gamma}= \\kappa^{\\boldsymbol \\eta}\\,, \\quad   {\\boldsymbol \\gamma}\\neq {\\boldsymbol \\eta}\\,..\n\\]\n\n\nTherefore curvature is not enough for characterizing space curves, and we need a new quantity. As we did with curvature, we start by considering the simpler case of unit speed curves. We will also need to assume that the curvature is never zero.\n\nDefinition 27: Principal normal vectorLet \\({\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3\\) be a unit speed curve with \\[\n\\kappa(t) \\neq 0 \\,, \\quad \\forall \\,t \\in (a,b) \\,.\n\\] The principal normal vector to \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is \\[\n\\mathbf{n}(t) := \\frac{1}{\\kappa (t)} \\, \\ddot {\\boldsymbol \\gamma}(t) \\,.\n\\]\n\n\n\nRemark 28\nSince for \\({\\boldsymbol \\gamma}\\) unit speed we defined \\[\n\\kappa (t) := \\left\\|  \\ddot {\\boldsymbol \\gamma}(t)  \\right\\| \\,,\n\\] we have that \\[\n\\left\\|  \\mathbf{n}(t)  \\right\\| = 1 \\,,\n\\] thus \\(\\mathbf{n}\\) is a unit vector. Moreover \\(\\mathbf{n}\\) is orthogonal to \\(\\dot{\\boldsymbol \\gamma}\\), that is, \\[\n\\dot {\\boldsymbol \\gamma}\\cdot \\mathbf{n}= 0 \\,.\n\\]\n\nThis is because \\[\n\\dot {\\boldsymbol \\gamma}\\cdot \\mathbf{n}= \\frac{1}{\\kappa} \\, \\dot {\\boldsymbol \\gamma}\\cdot \\ddot {\\boldsymbol \\gamma}= 0 \\,,\n\\] where the last equality follows from \\(\\dot {\\boldsymbol \\gamma}\\cdot \\ddot {\\boldsymbol \\gamma}= 0\\), being \\({\\boldsymbol \\gamma}\\) unit speed.\n\n\n\n\n\n\nPrincipal normal vector \\(\\mathbf{n}(t)\\) to \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\).\n\n\n\nQuestion 29Why is the principal normal interesting? Because it can tell the difference beween a plane curve and a space curve. See picture below.\n\n\n\n\n\nLeft: Principal normal to a circle. Note that \\(\\mathbf{n}\\) always points towards the origin \\({\\boldsymbol 0}\\). Right: Principal normal to a helix. Note that \\(\\mathbf{n}\\) points towards the \\(z\\)-axis, but never towards the same point.\n\n\n\nDefinition 30: Binormal vectorLet \\({\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3\\) be a unit speed curve with \\[\n\\kappa(t) \\neq 0 \\,, \\quad \\forall \\,t \\in (a,b) \\,.\n\\] The binormal vector to \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is \\[\n\\mathbf{b}(t) := \\dot {\\boldsymbol \\gamma}(t) \\times \\mathbf{n}(t) \\,.\n\\]\n\n\n\nDefinition 31: Orthonormal basisLet \\(\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\) be vectors in \\(\\mathbb{R}^3\\). We say that the triple \\[\n\\{\\mathbf{v}_1, \\mathbf{v}_2,\\mathbf{v}_3\\}\n\\] is orthonormal if \\[\n\\left\\| v_i \\right\\| = 1 \\,, \\quad   v_i \\cdot v_j = 0 \\,, \\,\\, \\mbox{ for } \\, i \\neq j \\,.\n\\]\n\n\n\nProposition 32Let \\({\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3\\) be a unit speed curve with \\[\n\\kappa(t) \\neq 0 \\,, \\quad \\forall \\,t \\in (a,b) \\,.\n\\] Then the triple \\[\nB = (  \\dot {\\boldsymbol \\gamma}(t), \\mathbf{n}(t), \\mathbf{b}(t)  )\n\\] is a positive orthonormal basis of \\(\\mathbb{R}^3\\) for all \\(t \\in (a,b)\\).\n\n\n\nProofSince \\({\\boldsymbol \\gamma}\\) is unit speed we have \\[\n\\left\\|  \\dot {\\boldsymbol \\gamma}(t)  \\right\\| \\equiv 1 \\,.\n\\] Moreover we have already observed that \\[\n\\left\\| \\mathbf{n}(t) \\right\\| \\equiv 1 \\,, \\quad \\dot {\\boldsymbol \\gamma}(t) \\cdot \\mathbf{n}(t) \\equiv 0 \\,.\n\\] As \\(\\mathbf{b}\\) is defined by \\[\n\\mathbf{b}:= \\dot {\\boldsymbol \\gamma}\\times \\mathbf{n}\\,,\n\\] by the properties of the vector product, see Proposition 12, it follows that \\[\n\\mathbf{b}\\cdot \\dot {\\boldsymbol \\gamma}= 0 \\,, \\quad  \\mathbf{b}\\cdot \\mathbf{n}= 0  \\,.\n\\] By the calculation in Remark 13 Point 8, we have that \\[\n\\left\\|  \\mathbf{b} \\right\\|^2 = \\| \\dot {\\boldsymbol \\gamma}\\|^2 \\|\\mathbf{n}\\|^2 -   |\\dot {\\boldsymbol \\gamma}\\cdot \\mathbf{n}|^2 = 1   \\,.\n\\] This shows that the vectors \\[\n\\{ \\dot {\\boldsymbol \\gamma}, \\mathbf{n}, \\mathbf{b}\\}\n\\] are orthonormal. By the properties of the vector product, see Remark 13 Point 6, we also know that \\[\n( \\dot {\\boldsymbol \\gamma}, \\mathbf{n}, \\mathbf{b})\n\\] is a positive basis of \\(\\mathbb{R}^3\\).\n\n\n\nProposition 33Let \\({\\boldsymbol \\gamma}\\) be a unit speed curve with \\(\\kappa \\neq 0\\). Then \\[\n\\mathbf{b}= \\dot {\\boldsymbol \\gamma}\\times \\mathbf{n}\\,, \\quad\n\\mathbf{n}= \\mathbf{b}\\times \\dot {\\boldsymbol \\gamma}\\,, \\quad\n\\dot {\\boldsymbol \\gamma}= \\mathbf{n}\\times \\mathbf{b}\\,.\n\\tag{4.11}\\]\n\n\n\nProofThe first equality in (4.11) is true by definition of \\(\\mathbf{b}\\). For the other \\(2\\) equalities, recall formula (4.8): \\[\n(\\mathbf{u}\\times \\mathbf{v}) \\times \\mathbf{w}= ( \\mathbf{u}\\cdot \\mathbf{w}) \\mathbf{v}- ( \\mathbf{v}\\cdot \\mathbf{w}) \\mathbf{u}\\,,\n\\tag{4.12}\\] for all \\(\\mathbf{u},\\mathbf{v},\\mathbf{w}\\in \\mathbb{R}^3\\). Applying the above with \\[\n\\mathbf{u}= \\dot {\\boldsymbol \\gamma}\\,, \\quad \\mathbf{v}= \\mathbf{n}\\,, \\quad \\mathbf{w}= \\dot {\\boldsymbol \\gamma}\\,,\n\\] yields \\[\\begin{align}\n( \\dot {\\boldsymbol \\gamma}\\times \\mathbf{n}) \\times \\dot {\\boldsymbol \\gamma}& = ( \\dot {\\boldsymbol \\gamma}\\cdot \\dot {\\boldsymbol \\gamma}) \\mathbf{n}- (\\mathbf{n}\\cdot \\dot {\\boldsymbol \\gamma}) \\dot {\\boldsymbol \\gamma}\\\\\n                                      & = \\left\\| \\dot {\\boldsymbol \\gamma} \\right\\|^2 \\mathbf{n}- 0 \\\\\n                                      & = \\mathbf{n}\\,,\n\\end{align}\\] where we used that \\(\\dot{\\boldsymbol \\gamma}\\) is a unit vector and \\(\\mathbf{n}\\cdot \\dot {\\boldsymbol \\gamma}= 0\\). Therefore, by definition of \\(\\mathbf{b}\\), we have \\[\n\\mathbf{b}\\times \\dot {\\boldsymbol \\gamma}= ( \\dot {\\boldsymbol \\gamma}\\times \\mathbf{n}) \\times \\dot {\\boldsymbol \\gamma}= \\mathbf{n}\n\\] showing the second equality in (4.11). For showing the third equality, we apply (4.12) with \\[\n\\mathbf{u}= \\dot {\\boldsymbol \\gamma}\\,, \\quad \\mathbf{v}= \\mathbf{n}\\,, \\quad \\mathbf{w}= \\mathbf{n}\\,,\n\\] to get \\[\\begin{align}\n( \\dot {\\boldsymbol \\gamma}\\times \\mathbf{n}) \\times \\mathbf{n}& = ( \\dot {\\boldsymbol \\gamma}\\cdot \\mathbf{n}) \\mathbf{n}- (\\mathbf{n}\\cdot \\mathbf{n}) \\dot {\\boldsymbol \\gamma}\\\\\n                                      & = 0 - \\left\\| \\mathbf{n} \\right\\|^2 \\dot {\\boldsymbol \\gamma}\\\\\n                                      & = - \\dot {\\boldsymbol \\gamma}\n\\end{align}\\] where we used that \\(\\mathbf{n}\\) is a unit vector and \\(\\dot {\\boldsymbol \\gamma}\\cdot \\mathbf{n}= 0\\). Therefore, by definition of \\(\\mathbf{b}\\) and anti-commutativity of the vector product, we have \\[\n\\mathbf{n}\\times \\mathbf{b}= - \\mathbf{b}\\times \\mathbf{n}= - (\\dot {\\boldsymbol \\gamma}\\times \\mathbf{n}) \\times \\mathbf{n}= \\dot {\\boldsymbol \\gamma}\\,,\n\\] showing the last equality in (4.11).\n\n\n\nProposition 34Let \\({\\boldsymbol \\gamma}\\) be a unit speed curve with \\(\\kappa \\neq 0\\). Then \\[\n\\dot{\\mathbf{b}} (t) = - \\tau(t) \\mathbf{n}(t) \\,,\n\\tag{4.13}\\] for some \\(\\tau(t) \\in \\mathbb{R}\\).\n\n\n\nProofBy definition of \\(\\mathbf{b}\\) and the formula of derivation of the cross product (4.9) we have \\[\\begin{align}\n\\dot{\\mathbf{b}} & = \\frac{d}{dt} ( \\dot {\\boldsymbol \\gamma}\\times \\mathbf{n}) \\\\\n          & = \\ddot {\\boldsymbol \\gamma}\\times \\mathbf{n}+ \\dot {\\boldsymbol \\gamma}\\times \\dot{\\mathbf{n}} \\\\\n          & =  \\dot {\\boldsymbol \\gamma}\\times \\dot{\\mathbf{n}} \\,,\n\\end{align}\\] where we used that \\[\n\\ddot {\\boldsymbol \\gamma}\\times \\mathbf{n}= 0\\,,\n\\] since \\(\\mathbf{n}\\) is defined by \\(\\mathbf{n}:= \\ddot {\\boldsymbol \\gamma}/\\kappa\\), and therefore \\(\\mathbf{n}\\) and \\(\\ddot {\\boldsymbol \\gamma}\\) are parallel. Hence, we have proven that \\[\n\\dot{\\mathbf{b}} = \\dot {\\boldsymbol \\gamma}\\times \\dot{\\mathbf{n}} \\,.\n\\tag{4.14}\\] By the properties of the cross product we have that \\(\\mathbf{u}\\times \\mathbf{v}\\) is orthogonal to both \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\). Thus (4.14) implies that \\[\n\\dot{\\mathbf{b}} \\cdot \\dot {\\boldsymbol \\gamma}= 0 \\,.\n\\] Further, observe that \\[\n\\frac{d}{dt}( \\mathbf{b}\\cdot \\mathbf{b}) = \\dot{\\mathbf{b}} \\cdot \\mathbf{b}+ \\mathbf{b}\\cdot \\dot{\\mathbf{b}} = 2\\dot{\\mathbf{b}} \\cdot \\mathbf{b}\\,.\n\\] On the other hand, since \\(\\mathbf{b}\\) is a unit vector, we have \\[\n\\frac{d}{dt}( \\mathbf{b}\\cdot \\mathbf{b}) = \\frac{d}{dt}( \\left\\| \\mathbf{b} \\right\\|^2 ) = \\frac{d}{dt}( 1 ) = 0 \\,  \n\\] Therefore \\[\n\\dot{\\mathbf{b}} \\cdot \\mathbf{b}= 0 \\,.\n\\] To summarize, we have shown that \\(\\dot{\\mathbf{b}}\\) is orthogonal to \\(\\mathbf{b}\\) and \\(\\dot {\\boldsymbol \\gamma}\\). Since \\[\n( \\dot{\\boldsymbol \\gamma}, \\mathbf{n}, \\mathbf{b})\n\\] is an orthonormal basis of \\(\\mathbb{R}^3\\) we conclude that \\(\\dot{\\mathbf{b}}\\) is parallel to \\(\\mathbf{n}\\). Therefore there exists \\(\\tau(t) \\in \\mathbb{R}\\) such that \\[\n\\dot{\\mathbf{b}} = - \\tau(t) \\mathbf{n}(t) \\,,\n\\] concluding the proof.\n\n\nThe scalar \\(\\tau\\) in equation (4.13) is called the torsion of \\({\\boldsymbol \\gamma}\\).\n\nDefinition 35: Torsion of unit speed curveLet \\({\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3\\) be a unit speed curve, with \\(\\kappa \\neq 0\\). The torsion of \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) is the unique scalar \\[\n\\tau (t) \\in \\mathbb{R}\n\\] such that \\[\n\\dot{\\mathbf{b}} (t) = - \\tau(t) \\mathbf{n}(t) \\,.\n\\]\n\n\n\nRemark 36\nIn particular the torsion satisfies: \\[\n\\tau(t) = - \\dot{\\mathbf{b}} (t) \\cdot \\mathbf{n}(t) \\,.\n\\]\n\nThe above can be immediately obtained by multiplying (4.13) by \\(\\mathbf{n}\\). Indeed, \\[\n\\dot{\\mathbf{b}} = - \\tau \\mathbf{n}\\quad \\implies \\quad\n\\dot{\\mathbf{b}} \\cdot \\mathbf{n}= - \\tau \\mathbf{n}\\cdot \\mathbf{n}= \\tau \\,,\n\\] since \\(\\mathbf{n}\\) is a unit vector.\n\n\n\n\nWarningThe torsion is defined only for curves\n\\[\n{\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3 \\,,\n\\] with \\[\n\\left\\| \\dot {\\boldsymbol \\gamma} \\right\\| = 1 \\,, \\quad \\kappa = \\left\\|  \\ddot {\\boldsymbol \\gamma} \\right\\|  \\neq 0 \\,,\n\\] for all \\(t \\in (a,b)\\).\n\n\nWe can extend the definition of torsion to regular curves \\({\\boldsymbol \\gamma}\\) with non-vanishing curvature. In this case the torsion of \\({\\boldsymbol \\gamma}\\) is defined as the torsion of a unit speed reparametrization of \\({\\boldsymbol \\gamma}\\).\n\nDefinition 37Let \\({\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3\\) be a regular curve with non-vanishing curvature. Let \\(\\widetilde{{\\boldsymbol \\gamma}}\\) be a unit speed reparametrization of \\({\\boldsymbol \\gamma}\\), with \\[\n{\\boldsymbol \\gamma}= \\widetilde{{\\boldsymbol \\gamma}}\\circ \\phi \\,,  \\quad \\phi\\colon  (a,b) \\to (\\tilde{a},\\tilde{b})  \\,.\n\\] We define the torsion of \\({\\boldsymbol \\gamma}\\) at \\({\\boldsymbol \\gamma}(t)\\) as \\[\n\\tau^{\\boldsymbol \\gamma}(t) := \\tau^{\\widetilde{{\\boldsymbol \\gamma}}} ( \\phi(t) ) \\,,\n\\] where \\({\\tau}^{\\widetilde{{\\boldsymbol \\gamma}}}(s)\\) denotes the torsion of \\(\\widetilde{{\\boldsymbol \\gamma}}\\) at \\(\\widetilde{{\\boldsymbol \\gamma}}(s)\\).\n\n\nAs usual, it is possible to check that the above definition of torsion does not depend on the choice of unit speed reparametrization \\(\\widetilde{{\\boldsymbol \\gamma}}\\). As with curvature, there is a general formula to compute the torsion without having to reparametrize.\n\nProposition 38Let \\({\\boldsymbol \\gamma}\\colon (a,b) \\to \\mathbb{R}^3\\) be a regular curve with non-vanishing curvature. Then \\[\n\\tau (t) = \\frac{ ( \\dot{\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma}) \\cdot \\dddot {\\boldsymbol \\gamma}}{ \\left\\|  \\dot{\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\|^2 } \\,.\n\\]\n\n\nWe delay the proof of the above proposition for a bit. In the meantime, let us look at examples.\n\nExample 39: Torsion of Circle and HelixConsider the Helix of radius \\(R&gt;0\\) and rise \\(H&gt;0\\) \\[\n{\\boldsymbol \\gamma}(t) = ( R\\cos(t) , R\\sin(t) , Ht) \\,, \\quad t \\in \\mathbb{R}\\,.\n\\] We have already shown that \\[\n\\left\\| \\dot{\\boldsymbol \\gamma}(t) \\right\\|  = \\sqrt{R^2 + H^2}\\,,  \\quad  \\kappa = \\frac{R}{R^2 + H^2} \\,.\n\\] Therefore the Helix is regular with non-vanishing curvature. The torsion can be then computed via the formula \\[\n\\tau (t) = \\frac{ ( \\dot{\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma}) \\cdot \\dddot {\\boldsymbol \\gamma}}{ \\left\\|  \\dot{\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\|^2 } \\,.\n\\] Let us compute the quantities appearing in the formula for \\(\\tau\\) \\[\\begin{align}\n\\dot{\\boldsymbol \\gamma}(t) & = ( -R\\sin(t) , R\\cos(t) , H)  \\\\\n\\ddot{\\boldsymbol \\gamma}(t) & = ( -R\\cos(t) , -R\\sin(t) , 0) \\\\\n\\dddot{\\boldsymbol \\gamma}(t) & = ( R\\sin(t) , -R\\cos(t) , 0)\n\\end{align}\\] Moreover we had already computed that \\[\\begin{align}\n\\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma}& = \\left( RH\\sin(t), -RH\\cos(t), R^2 \\right)  \\\\\n\\left\\|  \\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\| & =  R\\sqrt{R^2 + H^2   } \\,.\n\\end{align}\\] Finally we compute \\[\n(\\dot {\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma}) \\cdot \\dddot {\\boldsymbol \\gamma}= R^2 H \\,.\n\\] We are ready to find the torsion: \\[\n\\tau = \\frac{ ( \\dot{\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma}) \\cdot \\dddot {\\boldsymbol \\gamma}}{ \\left\\|  \\dot{\\boldsymbol \\gamma}\\times \\ddot {\\boldsymbol \\gamma} \\right\\|^2 }\n       = \\frac{ H }{ R^2 + H^2 } \\,.\n\\]\n\n\n\nExample 40: Curvature and Torsion of CircleThe Circle of radius \\(R&gt;0\\) is \\[\n{\\boldsymbol \\gamma}(t) := ( R \\cos(t), R \\sin(t) , 0 ) \\,.\n\\] The curvature and torsion of the Helix of radius \\(R\\) and rise \\(H&gt;0\\) are \\[\n\\kappa = \\frac{R}{R^2 + H^2}\\,, \\quad \\tau = \\frac{H}{R^2 + H^2}  \\,.\n\\] As for \\(H=0\\) the Helix coincides with the Circle \\({\\boldsymbol \\gamma}\\), we obtain that the curvature and torsion of the Circle are \\[\n\\kappa = \\frac{1}{R}\\,, \\quad \\tau = 0  \\,.\n\\]\n\n\nFrom the above example we notice that the torsion of the circle is \\(0\\). This is true in general for plane curves. We will prove this claim in the next section. Let us see another example.\n\nExample 41Define the space curve \\[\n{\\boldsymbol \\gamma}(t) := \\left( \\frac45 \\cos(t),   ,   \\right) \\,,\n\\] for \\(t \\in \\mathbb{R}\\).\n\n\n\n\n\n\nCarmo, Manfredo P. do. 2017. Differential Geometry of Curves and Surfaces. Second Edition. Dover Books on Mathematics.\n\n\nPressley, Andrew. 2010. Elementary Differential Geometry. Second Edition. Springer."
  },
  {
    "objectID": "sections/chap_6.html",
    "href": "sections/chap_6.html",
    "title": "6  Topology",
    "section": "",
    "text": "Definition 1\nLet \\(X\\) be a set and \\(\\mathcal{T}\\) a collection of subsets of \\(X\\). We say that \\(\\mathcal{T}\\) is a topology on \\(X\\) if they hold:\n\nThe empty set \\(\\emptyset\\) and \\(X\\) belong to \\(\\mathcal{T}\\),\nLet \\(\\{A_i\\}_{i \\in I}\\) be an arbitrary family of elements of \\(\\mathcal{T}\\). Then \\[\n\\bigcup_{i \\in I} A_i  \\in \\mathcal{T}\\,.\n\\]\nIf \\(A,B \\in \\mathcal{T}\\) then \\[\nA \\cap B \\in \\mathcal{T}\\,.\n\\]\n\n\n\n\nDefinition 2Let \\((X,\\mathcal{T})\\) be a topological space. We say that \\(X\\) is connected if the only subsets of \\(X\\) which are both open and closed are just \\(\\emptyset\\) and \\(X\\)."
  },
  {
    "objectID": "sections/chap_7.html",
    "href": "sections/chap_7.html",
    "title": "7  Surfaces",
    "section": "",
    "text": "Definition 1\nA set \\(\\mathcal{S}\\subset \\mathbb{R}^3\\) is a surface if for every point \\(\\mathbf{p}\\in \\mathcal{S}\\) there exist open sets \\(U \\subset \\mathbb{R}^2\\), \\(V \\subset \\mathbb{R}^3\\) such that\n\n\\(\\mathbf{p}\\in V\\),\n\\(U\\) is diffeomorphic to \\(V \\cap \\mathcal{S}\\).\n\nFurther:\n\nA diffeomorphism of \\(U\\) into \\(V \\cap \\mathcal{S}\\), denoted by \\[\n{\\boldsymbol \\sigma}\\colon U \\to  V \\cap \\mathcal{S}\\,\n\\] is called a surface chart.\nFor each \\(i \\in I\\) suppose to have a surface chart \\[\n{\\boldsymbol \\sigma}_i  \\colon U_i \\to V_i \\cap \\mathcal{S}\\,.\n\\] We say that the family \\(\\{ {\\boldsymbol \\sigma}_i\\}_{i \\in I}\\) is an atlas of \\(\\mathcal{S}\\) if \\[\n\\bigcup_{i \\in I} (V_i \\cap \\mathcal{S}) = \\mathcal{S}\\,.\n\\]\n\n\n\nNote that a surface chart \\({\\boldsymbol \\sigma}\\) is a map from \\(\\mathbb{R}^2\\) into \\(\\mathbb{R}^3\\). Points in \\(U\\) will be denoted by the pair \\((u,v)\\), while points on \\(\\mathcal{S}\\) by \\(\\mathbf{p}\\) and points in \\(\\mathbb{R}^3\\) by \\(\\mathbf{x}\\).\n\nDefinition 2Let \\(U \\subset \\mathbb{R}^2\\) be open A surface chart \\[\n{\\boldsymbol \\sigma}= {\\boldsymbol \\sigma}(u,v)  \\colon U \\to \\mathbb{R}^3\n\\] is called regular if the partial derivatives \\[\n{\\boldsymbol \\sigma}_u(u,v) = \\frac{d{\\boldsymbol \\sigma}}{du}(u,v) \\,, \\quad\n{\\boldsymbol \\sigma}_v(u,v) = \\frac{d{\\boldsymbol \\sigma}}{dv}(u,v)\n\\] are linearly independent vectors of \\(\\mathbb{R}^3\\) for all \\((u,v) \\in U\\).\n\n\n\nDefinition 3Let \\(U \\subset \\mathbb{R}^2\\) be open. A surface chart \\[\n{\\boldsymbol \\sigma}\\colon U \\to \\mathbb{R}^3\n\\] is called a conformal parametrization if the first fundamental form satisfies \\[\nE \\, du^2 + F \\, du \\ dv + G \\, dv^2 = \\lambda(u,v)  ( du^2 +  dv^2)\n\\] for some smooth function \\(\\lambda \\colon U \\to \\mathbb{R}\\).\n\n\n\nDefinition 4Let \\(\\mathcal{S}\\) be a surface and \\({\\boldsymbol \\sigma}\\colon U \\to V \\cap \\mathcal{S}\\) a surface chart. The principal unit normal to \\(\\mathcal{S}\\) is \\[\n\\mathbf{N} = \\frac{ {\\boldsymbol \\sigma}_u \\times {\\boldsymbol \\sigma}_v }{ \\left\\| {\\boldsymbol \\sigma}_u \\times {\\boldsymbol \\sigma}_v \\right\\| } \\,.\n\\]\n\n\nDenote by \\[\n\\mathbb{S}^2 = \\{ \\mathbf{x}\\in \\mathbb{R}^3 \\, \\colon \\, \\left\\| \\mathbf{x} \\right\\| = 1 \\}\n\\] the unit sphere in \\(\\mathbb{R}^3\\).\n\nDefinition 5Let \\(\\mathcal{S}\\) be a surface and denote by \\(\\mathbf{N}\\) the principal unit normal. The Gauss map of \\(\\mathcal{S}\\) is the map \\(G \\colon \\mathcal{S}\\to \\mathbb{S}^2\\) defined by \\[\nG(\\mathbf{p}):= \\mathbf{N}(\\mathbf{p}) \\,.\n\\] The Weingarten map is the derivative of the Gauss map, denoted by \\(\\mathcal{W}\\colon T_{\\mathbf{p}}\\mathcal{S}\\to T_{G(\\mathbf{p})} \\mathbb{S}^2\\)."
  },
  {
    "objectID": "sections/chap_8.html#plots-with-matplotlib",
    "href": "sections/chap_8.html#plots-with-matplotlib",
    "title": "8  Surfaces in Python",
    "section": "8.1 Plots with Matplotlib",
    "text": "8.1 Plots with Matplotlib\nI will take for granted all the commands explained in Chapter 2. Suppose we want to plot a surface \\(S\\) which is defined by the parametric equations \\[\nx = x(u,v) \\,, \\quad\ny = y(u,v) \\,, \\quad\nz = z(u,v)\n\\] for \\(u \\in (a,b)\\) and \\(v \\in (c,d)\\). This can be done via the function called plot_surface contained in the mplot3d Toolkit. This function works as follows: first we generate a mesh-grid \\([U,V]\\) from the coordinates \\((u,v)\\) via the command\n[U, V] = np.meshgrid(u, v)\nThen we compute the parametric surface on the mesh\nx = x (U, V)\ny = y (U, V)\nz = z (U, V)\nFinally we can plot the surface with the command\nplt.plot_surface(x, y, z)\nThe complete code looks as follows.\n# Plotting surface S\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size m x n\nfig = plt.figure(figsize = (m,n))\n\n# Generates 3D axes\nax = plt.axes(projection = '3d')\n\n# Shows axes grid\nax.grid(True)\n\n# Generates coordinates u and v\n# by dividing the interval (a,b) in n parts\n# and the interval (c,d) in m parts\nu = np.linspace(a, b, m)\nv = np.linspace(c, d, n)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes S given the functions x, y, z\n# on the grid [U,V]\nx = x(U,V)\ny = y(U,V)\nz = z(U,V)\n\n# Plots the surface S\nax.plot_surface(x, y, z)\n\n# Setting plot title \nax.set_title('The surface S')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad=10)\nax.set_ylabel('y', labelpad=10)\nax.set_zlabel('z', labelpad=10)\n\n# Setting viewing angle\nax.view_init(elev = e, azim = a)\n\n# Showing the plot\nplt.show()\nFor example let us plot a cone described parametrically by: \\[\nx = u \\cos(v) \\,, \\quad\ny = u \\sin(v) \\,, \\quad\nz = u\n\\] for \\(u \\in (0,1)\\) and \\(v \\in (0,2\\pi)\\). We adapt the above code:\n\n# Plotting a cone\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size 4 x 4\nfig = plt.figure(figsize = (4,4))\n\n# Generates 3D axes\nax = plt.axes(projection = '3d')\n\n# Shows axes grid\nax.grid(True)\n\n# Generates coordinates u and v by dividing\n# the intervals (0,1) and (0,2pi) in 100 parts\nu = np.linspace(0, 1, 100)\nv = np.linspace(0, 2*np.pi, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the surface on grid [U,V]\nx = U * np.cos(V)\ny = U * np.sin(V)\nz = U\n\n# Plots the cone\nax.plot_surface(x, y, z)\n\n# Setting plot title \nax.set_title('Plot of a cone')\n\n# Setting axes labels\nax.set_xlabel('x', labelpad=10)\nax.set_ylabel('y', labelpad=10)\nax.set_zlabel('z', labelpad=10)\n\n# Setting viewing angle\nax.view_init(elev = 25, azim = 45)\n\n# Showing the plot\nplt.show()\n\n\n\n\nAs discussed in Chapter 2, we can have multiple plots in the same figure. For example let us plot the torus viewed from 2 angles. The parametric equations are: \\[\n\\begin{aligned}\nx & = (R + r \\cos(u)) \\cos(v)  \\\\\ny & = (R + r \\cos(u)) \\sin(v)  \\\\\nz & = r \\sin(u)\n\\end{aligned}\n\\] for \\(u, v \\in (0,2\\pi)\\) and with\n\n\\(R\\) distance from the center of the tube to the center of the torus\n\\(r\\) radius of the tube\n\n\n# Plotting torus seen from 2 angles\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size 9 x 5\nfig = plt.figure(figsize = (9,5))\n\n# Generates 2 sets of 3D axes\nax1 = fig.add_subplot(1, 2, 1, projection = '3d')\nax2 = fig.add_subplot(1, 2, 2, projection = '3d')\n\n# Shows axes grid\nax1.grid(True)\nax2.grid(True)\n\n# Generates coordinates u and v by dividing\n# the interval (0,2pi) in 100 parts\nu = np.linspace(0, 2*np.pi, 100)\nv = np.linspace(0, 2*np.pi, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the torus on grid [U,V]\n# with radii r = 1 and R = 2\nR = 2\nr = 1\n\nx = (R + r * np.cos(U)) * np.cos(V)\ny = (R + r * np.cos(U)) * np.sin(V)\nz = r * np.sin(U)\n\n# Plots the torus on both axes\nax1.plot_surface(x, y, z, rstride = 5, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\nax2.plot_surface(x, y, z, rstride = 5, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\n# Setting plot titles \nax1.set_title('Torus')\nax2.set_title('Torus from above')\n\n# Setting range for z axis in ax1\nax1.set_zlim(-3,3)\n\n# Setting viewing angles\nax1.view_init(elev = 35, azim = 45)\nax2.view_init(elev = 90, azim = 0)\n\n# Showing the plot\nplt.show()\n\n\n\n\nNotice that we have added some customization to the plot_surface command. Namely, we have set the color of the figure with color = 'dimgray' and of the edges with edgecolors = 'snow'. Moreover the commands rstride and cstride set the number of wires you see in the plot. More precisely, they set by how much the data in the mesh \\([U,V]\\) is downsampled in each direction, where rstride sets the row direction, and cstride sets the column direction. On the torus this is a bit difficult to visualize, due to the fact that \\([U,V]\\) represents angular coordinates. To appreciate the effect, we can plot for example the paraboiloid \\[\n\\begin{aligned}\nx & = u  \\\\\ny & = v  \\\\\nz & = - u^2 - v^2\n\\end{aligned}\n\\] for \\(u,v \\in [-1,1]\\).\n\n# Showing the effect of rstride and cstride\n\n# Importing numpy, matplotlib and mplot3d\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits import mplot3d\n\n# Generates figure object of size 6 x 6\nfig = plt.figure(figsize = (6,6))\n\n# Generates 2 sets of 3D axes\nax1 = fig.add_subplot(2, 2, 1, projection = '3d')\nax2 = fig.add_subplot(2, 2, 2, projection = '3d')\nax3 = fig.add_subplot(2, 2, 3, projection = '3d')\nax4 = fig.add_subplot(2, 2, 4, projection = '3d')\n\n# Generates coordinates u and v by dividing\n# the interval (-1,1) in 100 parts\nu = np.linspace(-1, 1, 100)\nv = np.linspace(-1, 1, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the paraboloid on grid [U,V]\nx = U\ny = V\nz = - U**2 - V**2\n\n# Plots the paraboloid on the 4 axes\n# but with different stride settings\nax1.plot_surface(x, y, z, rstride = 5, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\nax2.plot_surface(x, y, z, rstride = 5, cstride = 20, color = 'dimgray', edgecolors = 'snow')\n\nax3.plot_surface(x, y, z, rstride = 20, cstride = 5, color = 'dimgray', edgecolors = 'snow')\n\nax4.plot_surface(x, y, z, rstride = 10, cstride = 10, color = 'dimgray', edgecolors = 'snow')\n\n# Setting plot titles \nax1.set_title('rstride = 5, cstride = 5')\nax2.set_title('rstride = 5, cstride = 20')\nax3.set_title('rstride = 20, cstride = 5')\nax4.set_title('rstride = 10, cstride = 10')\n\n# We do not plot axes, to get cleaner pictures\nax1.axis('off')\nax2.axis('off')\nax3.axis('off')\nax4.axis('off')\n\n# Showing the plot\nplt.show()\n\n\n\n\nIn this case our mesh is 100 x 100, since u and v both have 100 components. Therefore setting rstride and cstride to 5 implies that each row and column of the mesh is sampled one time every 5 elements, for a total of \\[\n100/5 = 20\n\\] samples in each direction. This is why in the first picture you see a 20 x 20 grid. If instead one sets rstride and cstride to 10, then each row and column of the mesh is sampled one time every 10 elements, for a total of \\[\n100/10 = 10\n\\] samples in each direction. This is why in the fourth figure you see a 10x10 grid."
  },
  {
    "objectID": "sections/chap_8.html#plots-with-plotly",
    "href": "sections/chap_8.html#plots-with-plotly",
    "title": "8  Surfaces in Python",
    "section": "8.2 Plots with Plotly",
    "text": "8.2 Plots with Plotly\nAs done in Section 2.4, we now see how to use Plotly to generate an interactive 3D plot of a surface. This can be done by means of functions contained in the Plotly module graph_objects, usually imported as go. Specifically, we will use the function go.Surface. The code will look similar to the one used to plot surfaces with matplotlib:\n\ngenerate meshgrid on which to compute the parametric surface,\nstore such surface in the numpy array [x,y,z],\npass the array [x,y,z] to go.Surface to produce the plot.\n\nThe full code is below.\n\n# Plotting a Torus with Plotly\n\n# Import \"numpy\" and the \"graph_objects\" module from Plotly\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Generates coordinates u and v by dividing\n# the interval (0,2pi) in 100 parts\nu = np.linspace(0, 2*np.pi, 100)\nv = np.linspace(0, 2*np.pi, 100)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Computes the torus on grid [U,V]\n# with radii r = 1 and R = 2\nR = 2\nr = 1\n\nx = (R + r * np.cos(U)) * np.cos(V)\ny = (R + r * np.cos(U)) * np.sin(V)\nz = r * np.sin(U)\n\n# Generate and empty figure object with Plotly\n# and saves it to the variable called \"fig\"\nfig = go.Figure()\n\n# Plot the torus with go.Surface and store it\n# in the variable \"data\". We also do now show the\n# plot scale, and set the color map to \"teal\"\ndata = go.Surface(\n    x = x , y = y, z = z, \n    showscale = False, \n    colorscale='teal'\n    )\n\n# Add the plot stored in \"data\" to the figure \"fig\"\n# This is done with the command add_trace\nfig.add_trace(data)\n\n# Set the title of the figure in \"fig\"\nfig.update_layout(title_text=\"Plotting a Torus with Plotly\")\n\n# Show the figure\nfig.show()\n\n\n                                                \n\n\nYou can rotate the above image by clicking on it and dragging the cursor. To further customize your plots, you can check out the documentation of go.Surface at this link. For example, note that we have set the colormap to teal: for all the pretty colorscales available in Plotly, see this page.\nOne could go even fancier and use the tri-surf plots in Plotly. This is done with the function create_trisurf contained in the module figure_factory of Plotly, usually imported as ff. The documentation can be found here. We also need to import the Python library scipy, which we use to generate a Delaunay triangulation for our plot. Let us for example plot the torus.\n\n# Plotting Torus with tri-surf\n\n# Importing libraries\nimport numpy as np\nimport plotly.figure_factory as ff\nfrom scipy.spatial import Delaunay\n\n# Generates coordinates u and v by dividing\n# the interval (0,2pi) in 100 parts\nu = np.linspace(0, 2*np.pi, 20)\nv = np.linspace(0, 2*np.pi, 20)\n\n# Generates grid [U,V] from the coordinates u, v\nU, V = np.meshgrid(u, v)\n\n# Collapse meshes to 1D array\n# This is needed for create_trisurf \nU = U.flatten()\nV = V.flatten()\n\n# Computes the torus on grid [U,V]\n# with radii r = 1 and R = 2\nR = 2\nr = 1\n\nx = (R + r * np.cos(U)) * np.cos(V)\ny = (R + r * np.cos(U)) * np.sin(V)\nz = r * np.sin(U)\n\n# Generate Delaunay triangulation\npoints2D = np.vstack([U,V]).T\ntri = Delaunay(points2D)\nsimplices = tri.simplices\n\n# Plot the Torus\nfig = ff.create_trisurf(\n    x=x, y=y, z=z,\n    colormap = \"Portland\",\n    simplices=simplices,\n    title=\"Torus with tri-surf\", \n    aspectratio=dict(x=1, y=1, z=0.3),\n    show_colorbar = False\n    )\n\n# Adjust figure size\nfig.update_layout(autosize = False, width = 700, height = 700)\n\n# Show the figure\nfig.show()\n\n\n                                                \n\n\nAgain, the above figure is interactive. Try rotating the torus with the pointer."
  },
  {
    "objectID": "sections/license.html#reuse",
    "href": "sections/license.html#reuse",
    "title": "License",
    "section": "Reuse",
    "text": "Reuse\nThis work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License"
  },
  {
    "objectID": "sections/license.html#citation",
    "href": "sections/license.html#citation",
    "title": "License",
    "section": "Citation",
    "text": "Citation\nFor attribution, please cite this work as:\n\nFanzon, Silvio. (2023). Lecture Notes on Differential Geometry.\nhttps://www.silviofanzon.com/2023-Differential-Geometry-Notes/\n\nBibTex citation:\n@electronic{Danzon-Diff-Geom-2023,\n    author = {Fanzon, Silvio},\n    title = {Lecture Notes on Differential Geometry},\n    url = {https://www.silviofanzon.com/2023-Differential-Geometry-Notes/},\n    year = {2023}}"
  },
  {
    "objectID": "sections/references.html",
    "href": "sections/references.html",
    "title": "References",
    "section": "",
    "text": "Bär, Christian. 2010. Elementary Differential Geometry.\nCambridge University Press.\n\n\nCarmo, Manfredo P. do. 2017. Differential Geometry of Curves and\nSurfaces. Second Edition. Dover Books on Mathematics.\n\n\nJohansson, Robert. 2019. Numerical Python. Scientific Computing and\nData Science Applications with Numpy, SciPy and Matplotlib. Second\nEdition. Apress.\n\n\nKong, Qingkai, Timmy Siauw, and Alexandre Bayen. 2020. Python\nProgramming and Numerical Methods. Academic Press.\n\n\nPressley, Andrew. 2010. Elementary Differential Geometry.\nSecond Edition. Springer.\n\n\nZorich, Vladimir A. 2015. Mathematical Analysis i. Second\nEdition. Springer.\n\n\n———. 2016. Mathematical Analysis II. Second Edition. Springer."
  }
]